<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Jupyter Notebook</title><url>/post/tools/jupyter-notebook/</url><categories><category>Tool</category></categories><tags><tag>Jupyter</tag><tag>Notebook</tag></tags><content type="html"><![CDATA[写这篇博客的目的，大概是身边很多人都认为 Jupyter Notebook 是 Python 专属的，但其实 Jupyter 是支持很多其他 kernel 的，在学习一门新的语言、或是对于一些新的语言特性不确定的时候，用 Jupyter 来测试会十分方便，尤其是对于像 C++、Go、Rust 这种编译型语言。
部署流程 出于安全性考虑，请不要使用 root 用户运行 Jupyter，因为 Jupyter 默认是开启 Terminal 的，即使关掉，通过编程语言的接口，也可以直接对系统进行操作。该流程在容器中部署，同时用非 root 用户运行，提供了一定的安全保障。 Dockerfile 下面的 Dockerfile 会装 C++, Go, Rust 这 3 个 kernel，可以参考官方 wiki 装其他 kernel。如果 Host 系统不是 x86_64 架构的，Miniconda 和 Go 需要下载对应架构的 release（可能会踩一些坑 🤣）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 FROM debian:bullseye-slim ARG USER=notebook ARG HOME=/home/${USER} RUN adduser --disabled-password --gecos &#34;&#34; --home ${HOME} ${USER} RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive &amp;&amp; \ apt-get install -y --no-install-recommends ca-certificates curl wget cmake build-essential &amp;&amp; \ rm -rf /var/lib/apt/lists/* USER ${USER} # install miniconda ENV PATH=${HOME}/miniconda3/bin:${PATH} RUN cd ${HOME} &amp;&amp; \ wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh &amp;&amp; \ bash Miniconda3-latest-Linux-x86_64.sh -b &amp;&amp; \ rm -f Miniconda3-latest-Linux-x86_64.sh # install jupyter RUN conda install -y jupyter # install C++ kernel RUN conda install -y xeus-cling -c conda-forge # clean conda cache RUN conda clean --all # install go kernel ENV PATH=${HOME}/go/bin:${PATH} RUN wget -qO- https://go.dev/dl/go1.19.linux-amd64.tar.gz | tar zxvf - -C ${HOME} RUN go install github.com/gopherdata/gophernotes@v0.7.5 &amp;&amp; \ mkdir -p ${HOME}/.local/share/jupyter/kernels/gophernotes &amp;&amp; \ cd ${HOME}/.local/share/jupyter/kernels/gophernotes &amp;&amp; \ cp &#34;$(go env GOPATH)&#34;/pkg/mod/github.com/gopherdata/gophernotes@v0.7.5/kernel/* ./ &amp;&amp; \ chmod +w kernel.json &amp;&amp; \ sed &#34;s|gophernotes|$(go env GOPATH)/bin/gophernotes|&#34; &lt; kernel.json.in &gt; kernel.json # install rust kernel ENV PATH=${HOME}/.cargo/bin:${PATH} RUN cd ${HOME} &amp;&amp; \ curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs &gt; rustup-init.sh &amp;&amp; \ bash rustup-init.sh -y &amp;&amp; \ rm -f rustup-init.sh RUN rustup component add rust-src &amp;&amp; \ cargo install evcxr_jupyter &amp;&amp; \ evcxr_jupyter --install RUN mkdir -p ${HOME}/notebook WORKDIR ${HOME}/notebook ENTRYPOINT [ &#34;jupyter&#34;, &#34;notebook&#34;, &#34;--ip=&#39;*&#39;&#34;, &#34;--port=8888&#34; ] 构建 docker 镜像 1 docker build -t notebook . 运行容器 1 docker run -d -p 8888:8888 --restart always --name notebook notebook 设置访问密码 1 docker exec -it notebook jupyter notebook password 重启容器 1 docker restart notebook 重置密码的流程也是 设置访问密码 后 重启容器 。 ]]></content></entry><entry><title>Ubuntu 18.04 通过 Kolla Ansible 部署 OpenStack Ussuri</title><url>/post/openstack/ubuntu-18-04-kolla-ansible-deploy-openstack-ussuri/</url><categories><category>Work</category></categories><tags><tag>OpenStack</tag><tag>Python</tag><tag>Shell</tag></tags><content type="html"><![CDATA[安装 Ubuntu 18.04 安装两台 Ubuntu 18.04，其中一台至少配置两块网卡，另一台至少配置一块网卡。
说明：配置两块网卡的作为控制节点 ( controller )，一块网卡的作为计算节点 ( compute )。
准备工作 ( controller, compute ) 配置 IP controller
设置控制节点 IP、网关变量
1 2 LOCAL_GATEWAY=192.168.56.1 LOCAL_ADDRESS=192.168.56.xxx 设置计算节点 IP
1 COMPUTE_ADDRESS=192.168.56.yyy 设置网络接口名称变量
网络接口名称需要根据实际修改，可使用命令 `ip a` 查看网卡信息 1 2 NETWORK_INTERFACE1=eno1 NETWORK_INTERFACE2=eno2 配置接口 IP
1 2 3 4 5 6 7 8 9 10 11 12 rm -r /etc/netplan/* &amp;&amp; \ tee /etc/netplan/controller.yaml &lt;&lt;- EOF network: version: 2 renderer: networkd ethernets: $NETWORK_INTERFACE1: addresses: [$LOCAL_ADDRESS/24] gateway4: $LOCAL_GATEWAY $NETWORK_INTERFACE2: dhcp4: false EOF compute
设置 compute IP 及网关变量
1 2 LOCAL_GATEWAY=192.168.56.1 LOCAL_ADDRESS=192.168.56.yyy `compute` 的网络接口名称必需与 `controller` 的一致 设置网络接口名称和 MAC 地址变量
`NETWORK_INTERFACE` 为修改后的网络接口名称 1 2 NETWORK_INTERFACE=eno1 NETWORK_INTERFACE_MAC=xx:yy:xx:yy:xx:yy 可使用以下方法修改网络接口名称：
新建规则 1 2 3 tee /etc/udev/rules.d/70-persistent-net.rules &lt;&lt;- EOF SUBSYSTEM==&#34;net&#34;, ACTION==&#34;add&#34;, DRIVERS==&#34;?*&#34;, ATTR{address}==&#34;$NETWORK_INTERFACE_MAC&#34;, NAME=&#34;$NETWORK_INTERFACE&#34; EOF 修改 grub 1 sed -i &#34;s|GRUB_CMDLINE_LINUX=\&#34;\&#34;|GRUB_CMDLINE_LINUX=\&#34;net.ifnames=1 biosdevname=0\&#34;|g&#34; /etc/default/grub 更新 bootloader 1 update-grub 更新 initram 1 update-initramfs -u 配置接口 IP
1 2 3 4 5 6 7 8 9 10 rm -r /etc/netplan/* &amp;&amp; \ tee /etc/netplan/compute.yaml &lt;&lt;- EOF network: version: 2 renderer: networkd ethernets: $NETWORK_INTERFACE: addresses: [$LOCAL_ADDRESS/24] gateway4: $LOCAL_GATEWAY EOF 检查文件 ( controller ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 /root ├── bionic-server-cloudimg-amd64.img ├── CentOS-7-x86_64-GenericCloud.qcow2.xz ├── cirros-0.5.1-x86_64-disk.img ├── create_dual_intermediate_CA.sh ├── images │ ├── registry.tar │ ├── ubuntu.tar │ ├── ubuntu-source-aodh-api.tar │ ├── ubuntu-source-aodh-evaluator.tar │ ├── ubuntu-source-aodh-listener.tar │ ├── ubuntu-source-aodh-notifier.tar │ ├── ubuntu-source-ceilometer-central.tar │ ├── ubuntu-source-ceilometer-compute.tar │ ├── ubuntu-source-ceilometer-notification.tar │ ├── ubuntu-source-chrony.tar │ ├── ubuntu-source-cinder-api.tar │ ├── ubuntu-source-cinder-backup.tar │ ├── ubuntu-source-cinder-scheduler.tar │ ├── ubuntu-source-cinder-volume.tar │ ├── ubuntu-source-cron.tar │ ├── ubuntu-source-etcd.tar │ ├── ubuntu-source-fluentd.tar │ ├── ubuntu-source-glance-api.tar │ ├── ubuntu-source-gnocchi-api.tar │ ├── ubuntu-source-gnocchi-metricd.tar │ ├── ubuntu-source-heat-api-cfn.tar │ ├── ubuntu-source-heat-api.tar │ ├── ubuntu-source-heat-engine.tar │ ├── ubuntu-source-horizon.tar │ ├── ubuntu-source-iscsid.tar │ ├── ubuntu-source-keystone-fernet.tar │ ├── ubuntu-source-keystone-ssh.tar │ ├── ubuntu-source-keystone.tar │ ├── ubuntu-source-kolla-toolbox.tar │ ├── ubuntu-source-kuryr-libnetwork.tar │ ├── ubuntu-source-mariadb-clustercheck.tar │ ├── ubuntu-source-mariadb.tar │ ├── ubuntu-source-memcached.tar │ ├── ubuntu-source-neutron-dhcp-agent.tar │ ├── ubuntu-source-neutron-l3-agent.tar │ ├── ubuntu-source-neutron-metadata-agent.tar │ ├── ubuntu-source-neutron-openvswitch-agent.tar │ ├── ubuntu-source-neutron-server.tar │ ├── ubuntu-source-nova-api.tar │ ├── ubuntu-source-nova-compute.tar │ ├── ubuntu-source-nova-conductor.tar │ ├── ubuntu-source-nova-libvirt.tar │ ├── ubuntu-source-nova-novncproxy.tar │ ├── ubuntu-source-nova-scheduler.tar │ ├── ubuntu-source-nova-ssh.tar │ ├── ubuntu-source-octavia-api.tar │ ├── ubuntu-source-octavia-health-manager.tar │ ├── ubuntu-source-octavia-housekeeping.tar │ ├── ubuntu-source-octavia-worker.tar │ ├── ubuntu-source-openvswitch-db-server.tar │ ├── ubuntu-source-openvswitch-vswitchd.tar │ ├── ubuntu-source-panko-api.tar │ ├── ubuntu-source-placement-api.tar │ ├── ubuntu-source-rabbitmq.tar │ ├── ubuntu-source-tgtd.tar │ ├── ubuntu-source-titan-api.tar │ ├── ubuntu-source-titan-scaling.tar │ ├── ubuntu-source-titan-scheduler.tar │ ├── ubuntu-source-zun-api.tar │ ├── ubuntu-source-zun-cni-daemon.tar │ ├── ubuntu-source-zun-compute.tar │ └── ubuntu-source-zun-wsproxy.tar ├── init-runonce ├── kolla-ansible.tar.gz ├── multinode ├── openssl.cnf ├── prediction_train.csv ├── python-titanclient.tar.gz ├── test-only-amphora-x64-haproxy-ubuntu-bionic.qcow2 ├── trusted.gpg └── Windows 2016 Server.qcow.gz 配置自定义源 IP 及端口 1 2 CUSTOM_MIRROR_HOST=192.168.56.zzz CUSTOM_MIRROR_PORT=81 配置 apt 源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 tee /etc/apt/sources.list &lt;&lt;- EOF deb http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic main restricted universe multiverse deb-src http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic main restricted universe multiverse deb http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic-security main restricted universe multiverse deb-src http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic-security main restricted universe multiverse deb http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic-updates main restricted universe multiverse deb http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic-proposed main restricted universe multiverse deb http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/ubuntu/ bionic-backports main restricted universe multiverse deb [arch=amd64 trusted=yes] http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/docker-ce/linux/ubuntu/ bionic stable # deb-src [arch=amd64 trusted=yes] http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/docker-ce/linux/ubuntu/ bionic stable EOF 配置 pip 源 1 2 3 4 5 mkdir -p $HOME/.config/pip &amp;&amp; tee $HOME/.config/pip/pip.conf &lt;&lt;- EOF [global] index-url = http://$CUSTOM_MIRROR_HOST:$CUSTOM_MIRROR_PORT/pypi/simple/ trusted-host = $CUSTOM_MIRROR_HOST EOF 复制 GPG 公钥 1 cp $HOME/trusted.gpg /etc/apt/trusted.gpg 更新 apt 索引 1 apt update 安装 pip 1 apt install python3-pip -y 安装并创建、激活 python 虚拟环境、更新 pip 1 2 3 4 apt install python3-venv -y &amp;&amp; \ python3 -m venv --system-site-packages $HOME/venv &amp;&amp; \ . $HOME/venv/bin/activate &amp;&amp; \ pip install -U pip pip 安装 wheel ( 避免后续 build 时报错 ) 1 pip install wheel 安装 docker 1 apt install docker-ce -y 安装部署工具 ( controller ) 安装依赖 1 apt install python3-apt python3-dev libffi-dev gcc libssl-dev curl git lvm2 -y 安装 ansible 1 pip install -U &#39;ansible&lt;2.10&#39; 安装 kolla ansible 1 2 3 4 tar zxvf $HOME/kolla-ansible.tar.gz -C $HOME &amp;&amp; \ pip install -U -r $HOME/kolla-ansible/requirements.txt &amp;&amp; \ pip install -U $HOME/kolla-ansible &amp;&amp; \ rm -r $HOME/kolla-ansible 安装 OpenStack 客户端 1 pip install python-openstackclient 配置 kolla ansible ( controller ) 拷贝全局配置和密码配置文件 1 cp -r $HOME/venv/share/kolla-ansible/etc_examples/kolla /etc/ 设置 INVENTORY 变量 1 INVENTORY=multinode 配置 inventory *storage 为配置了 cinder 空闲卷的主机 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 tee $HOME/multinode_temp &lt;&lt;- EOF [control] $LOCAL_ADDRESS [network] $LOCAL_ADDRESS [compute] $LOCAL_ADDRESS $COMPUTE_ADDRESS [monitoring] $LOCAL_ADDRESS [storage] $COMPUTE_ADDRESS EOF cat multinode &gt;&gt; multinode_temp &amp;&amp; \ mv multinode_temp multinode 生成随机密码 1 kolla-genpwd 修改全局配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 tee -a /etc/kolla/globals.yml &lt;&lt;- EOF kolla_dev_repos_git: &#34;http://git.trystack.cn/openstack&#34; config_strategy: &#34;COPY_ALWAYS&#34; kolla_base_distro: &#34;ubuntu&#34; kolla_install_type: &#34;source&#34; openstack_release: &#34;ussuri&#34; kolla_internal_vip_address: &#34;$LOCAL_ADDRESS&#34; network_interface: &#34;$NETWORK_INTERFACE1&#34; neutron_external_interface: &#34;$NETWORK_INTERFACE2&#34; node_custom_config: &#34;/etc/kolla/config&#34; enable_haproxy: &#34;no&#34; enable_cinder: &#34;yes&#34; enable_cinder_backend_lvm: &#34;yes&#34; enable_etcd: &#34;yes&#34; enable_kuryr: &#34;yes&#34; enable_zun: &#34;yes&#34; docker_configure_for_zun: &#34;yes&#34; containerd_configure_for_zun: &#34;yes&#34; enable_aodh: &#34;yes&#34; enable_gnocchi: &#34;yes&#34; enable_panko: &#34;yes&#34; enable_ceilometer: &#34;yes&#34; enable_octavia: &#34;yes&#34; enable_titan: &#34;yes&#34; # nova_compute_virt_type: &#34;qemu&#34; # Must set this when deploying in virtual machines docker_registry: &#34;$LOCAL_ADDRESS:4000&#34; custom_docker_host: &#34;$CUSTOM_MIRROR_HOST&#34; custom_docker_port: &#34;$CUSTOM_MIRROR_PORT&#34; EOF 配置 cinder-volumes ( inventory 中的 storage 节点 ) 这里假设空闲分区为 /dev/sdb 1 2 3 free_device=/dev/sdb &amp;&amp; \ pvcreate $free_device &amp;&amp; \ vgcreate cinder-volumes $free_device 配置 SSH 密钥登录各节点，并确认主机指纹验证 生成 SSH 密钥对
输入以下命令后一直回车即可 1 ssh-keygen 将生成的 $HOME/.ssh/id_rsa.pub 文件内容拷贝至所有节点的 /root/.ssh/authorized_keys 文件并修改文件权限：
(controller, compute)
1 chmod 644 /root/.ssh/authorized_keys 测试多节点配置 第一次连接的话需要手动输入 yes 进行确认 1 ansible -i $HOME/$INVENTORY all -m ping 设置 ansible 的 python 解释器 1 2 3 4 tee $HOME/.ansible.cfg &lt;&lt;- EOF [defaults] interpreter_python=$HOME/venv/bin/python EOF 额外配置 拷贝故障预测数据
1 2 mkdir -p /etc/kolla/config/horizon &amp;&amp; \ cp $HOME/prediction_train.csv /etc/kolla/config/horizon/ 创建 zun-cni 目录
1 mkdir -p /opt/cni/bin/ nova compute monitors
1 2 3 4 5 mkdir -p /etc/kolla/config/nova &amp;&amp; \ tee /etc/kolla/config/nova/nova.conf &lt;&lt;- EOF [DEFAULT] compute_monitors = cpu.virt_driver EOF octavia 配置 SSL 证书
`pass` 表示不用执行任何命令 获取创建证书脚本 1 pass 获取 SSL 配置文件 1 pass 生成 SSL 证书 1 2 export OCTAVIA_PASS=`awk &#39;/^octavia_ca_password:/ {print $2}&#39; /etc/kolla/passwords.yml` bash $HOME/create_dual_intermediate_CA.sh 拷贝 SSL 证书 1 2 mkdir -p /etc/kolla/config/octavia cp $HOME/dual_ca/etc/octavia/certs/* /etc/kolla/config/octavia/ 获取 kolla 镜像(controller) 导入本地镜像 1 2 3 cd $HOME/images &amp;&amp; \ for item in `ls`; do docker load -i $item; done &amp;&amp; \ cd $HOME 修改 ubuntu、registry、horizon 镜像 tag（如有必要） 1 2 3 docker tag d70eaf7277ea ubuntu:latest docker tag 2d4f4b5309b1 registry:latest docker tag 84ced3da8f79 kolla/ubuntu-source-horizon:ussuri 搭建本地 registry 服务器 1 docker run -d --name registry --restart=always -p 4000:5000 -v /opt/registry:/var/lib/registry registry 修改镜像 tag 1 2 3 for item in `docker images | awk &#39;/ ussuri / {print $1}&#39;`; do \ docker image tag $item:ussuri $LOCAL_ADDRESS:4000/$item:ussuri; \ done 部署 (controller) Kolla Ansible Bootstrap Servers 1 kolla-ansible -i $HOME/$INVENTORY bootstrap-servers 上传镜像至本地 registry 服务器 1 for item in $(docker images | awk &#34;/$LOCAL_ADDRESS:4000/ {print \$1}&#34;); do docker push $item:ussuri; done Kolla Ansible Pre-Checks 1 kolla-ansible -i $HOME/$INVENTORY prechecks Kolla Ansible Deploy 1 kolla-ansible -i $HOME/$INVENTORY deploy Kolla Ansible Post Deploy 1 kolla-ansible -i $HOME/$INVENTORY post-deploy 配置 (controller) 配置管理员环境 1 . /etc/kolla/admin-openrc.sh 配置初始化脚本 $HOME/init-runonce
请根据实际 IP 信息修改下列 IP / 网段 1 2 3 EXT_NET_CIDR=${EXT_NET_CIDR:-&#39;192.168.56.0/24&#39;} EXT_NET_RANGE=${EXT_NET_RANGE:-&#39;start=192.168.56.221,end=192.168.56.230&#39;} EXT_NET_GATEWAY=${EXT_NET_GATEWAY:-&#39;192.168.56.1&#39;} 执行初始化脚本 1 bash $HOME/init-runonce 额外配置 (controller) 设置环境变量 1 2 3 4 5 KOLLA_OPENSTACK_COMMAND=openstack ADMIN_USER_ID=$($KOLLA_OPENSTACK_COMMAND user list | awk &#39;/ admin / {print $2}&#39;) ADMIN_PROJECT_ID=$($KOLLA_OPENSTACK_COMMAND project list | awk &#39;/ admin / {print $2}&#39;) ADMIN_SEC_GROUP=$($KOLLA_OPENSTACK_COMMAND security group list --project ${ADMIN_PROJECT_ID} | awk &#39;/ default / {print $2}&#39;) ADMIN_DOMAIN_ID=$($KOLLA_OPENSTACK_COMMAND domain show Default | awk &#39;/ id / {print $4}&#39;) 设置 admin domain ID 1 2 3 tee -a /etc/kolla/admin-openrc.sh &lt;&lt;- EOF export OS_USER_DOMAIN_ID=$ADMIN_DOMAIN_ID EOF root 用户配置 获取 root 用户密码
1 ROOT_PASS=$(awk &#39;/^root_user_password:/ {print $2}&#39; /etc/kolla/passwords.yml) 创建 root 用户
1 $KOLLA_OPENSTACK_COMMAND user create --domain $ADMIN_DOMAIN_ID --project-domain $ADMIN_PROJECT_ID --password $ROOT_PASS root 修改 root 角色
1 2 3 $KOLLA_OPENSTACK_COMMAND role add --system all --user root admin $KOLLA_OPENSTACK_COMMAND role add --project admin --user root heat_stack_owner $KOLLA_OPENSTACK_COMMAND role add --project admin --user root admin 使用 root 用户
1 2 export OS_USERNAME=root export OS_PASSWORD=$ROOT_PASS 添加 root 用户密钥对
1 $KOLLA_OPENSTACK_COMMAND keypair create --public-key $HOME/.ssh/id_rsa.pub mykey 重启 titan 容器 1 docker restart titan_api titan_scheduler titan_scaling octavia 配置 获取 Network ID
1 NETWORK_ID=$($KOLLA_OPENSTACK_COMMAND network list | awk &#39;/ public1 / {print $2}&#39;) 设置 Flavor ID
1 FLAVOR_ID=2 修改 Octavia Worker 配置
1 2 3 sed -i &#34;s|amp_boot_network_list =.*|amp_boot_network_list = $NETWORK_ID|g&#34; /etc/kolla/octavia-worker/octavia.conf sed -i &#34;s|amp_secgroup_list =.*|amp_secgroup_list = octavia|g&#34; /etc/kolla/octavia-worker/octavia.conf sed -i &#34;s|amp_flavor_id =.*|amp_flavor_id = $FLAVOR_ID|g&#34; /etc/kolla/octavia-worker/octavia.conf 创建 amphora 镜像
1 $KOLLA_OPENSTACK_COMMAND image create --public --disk-format qcow2 --file test-only-amphora-x64-haproxy-ubuntu-bionic.qcow2 --tag amphora amphora 获取 Octavia 密码
1 OCTAVIA_KEYSTONE_PASSWORD=$(awk &#39;/^octavia_keystone_password:/ {print $2}&#39; /etc/kolla/passwords.yml) 使用 Octavia 用户
1 2 3 4 export OS_USERNAME=octavia export OS_PASSWORD=$OCTAVIA_KEYSTONE_PASSWORD export OS_PROJECT_NAME=service export OS_TENANT_NAME=service 创建 octavia 安全组
1 $KOLLA_OPENSTACK_COMMAND security group create --description &#39;Used by octavia amphora instance&#39; octavia 为安全组添加规则
1 2 3 4 SECURITY_GROUP_ID=$($KOLLA_OPENSTACK_COMMAND security group list | awk &#39;/ octavia / {print $2}&#39;) $KOLLA_OPENSTACK_COMMAND security group rule create --protocol icmp $SECURITY_GROUP_ID $KOLLA_OPENSTACK_COMMAND security group rule create --protocol tcp --dst-port 22 --egress $SECURITY_GROUP_ID $KOLLA_OPENSTACK_COMMAND security group rule create --protocol tcp --dst-port 9443 --ingress $SECURITY_GROUP_ID 添加密钥对
1 $KOLLA_OPENSTACK_COMMAND keypair create --public-key $HOME/.ssh/id_rsa.pub octavia_ssh_key 重启 Octavia Worker 容器
1 docker restart octavia_worker ]]></content></entry><entry><title>Learn SICP Chapter 3</title><url>/post/sicp/learn-sicp-ch3/</url><categories><category>Learn</category></categories><tags><tag>Scheme</tag><tag>SICP</tag></tags><content type="html"><![CDATA[即使在变化中，它也丝毫未变。
------ 赫拉克立特（Heraclitus） 变得越多，它就越是原来的样子。
------ 阿尔芬斯 &#183; 卡尔（Alphonse Karr） 练习 1 一个累加器是一个过程，反复用数值参数调用它，就会使它的各个参数累加到一个和数中。每次调用时累加器将返回当前的累加和。请写出一个生成累加器的过程 make-accumulator，它所生成的每个累加器维持维持着一个独立的和。送给 make-accumulator 的输入描述了有关和数的初始值，例如：
1 2 3 4 5 6 7 (define A (make-accumulator 5)) (A 10) 15 (A 10) 25 1 2 3 4 5 6 #lang sicp (define (make-accumulator init) (lambda (value) (begin (set! init (+ init value)) init))) 练习 2 在对应用程序做软件测试时，能够统计出在计算过程中某个给定过程被调用的次数常常很有用处。请写出一个过程 make-monitored，它以一个过程 f 作为输入，该过程本身有一个输入。make-monitored 返回的结果是第三个过程，比如说 mf，它将用一个内部计数器维持着自己被调用的次数。如果 mf 的输入是特殊符号 how-many-calls?，那么 mf 就返回内部计数器的值；如果输入是特殊符号 reset-count，那么 mf 就将计数器重新设置为 0；对于任何其他输入，mf 将返回过程 f 应用于这一输入的结果，并将内部计数器加一。例如，我们可能以下面方式做出过程 sqrt 的一个受监视的版本：
1 2 3 4 5 6 7 (define s (make-monitored sqrt)) (s 100) 10 (s &#39;how-many-calls?) 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #lang sicp (define (make-monitored f) (let ((_count 0)) (lambda (arg) (cond ((eq? arg &#39;how-many-calls?) _count) ((eq? arg &#39;reset-count) (set! _count 0)) (else (begin (set! _count (+ _count 1)) (f arg))))))) ;&gt;&gt;&gt; (define s (make-monitored sqrt)) ;&gt;&gt;&gt; (s 100) ;: 10 ;&gt;&gt;&gt; (s 2) ;: 1.4142135623730951 ;&gt;&gt;&gt; (s &#39;how-many-calls?) ;: 2 ;&gt;&gt;&gt; (s &#39;reset-count) ;&gt;&gt;&gt; (s &#39;how-many-calls?) ;: 0 练习 3 请修改 make-account 过程，使它能创建一种带密码保护的账户。也就是说，应该让 make-account 以一个符号作为附加的参数，就像：
1 (define acc (make-account 100 &#39;secret-password)) 这样产生的账户对象在接到一个请求时，只有同时提供了账户提供了账户创建时给定的密码，它才处理这一请求，否则就发出一个抱怨信息：
1 2 3 4 5 ((acc &#39;secret-password &#39;withdraw) 40) 60 ((acc &#39;some-other-password &#39;deposit) 50) &#34;Incorrect password&#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #lang sicp (define (make-account balance password) (define (withdraw amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) &#34;Insufficient funds&#34;)) (define (deposit amount) (begin (set! balance (+ balance amount)) balance)) (define (dispatch pass m) (if (eq? pass password) (cond ((eq? m &#39;withdraw) withdraw) ((eq? m &#39;deposit) deposit) (else (error &#34;Unknown request -- MAKE-ACCOUNT&#34; m))) (lambda (arg . args) &#34;Incorrect password&#34;))) dispatch) 练习 4 请修改 练习 3 中的 make-account 过程，加上另一个局部状态变量，使得如果一个账户被用不正确的密码连续访问了 7 次，它就将去调用过程 call-the-cops（叫警察）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #lang sicp (define (call-the-cops) &#34;Cops are coming&#34;) (define (make-account balance password) (let ((times 7)) (define (withdraw amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) &#34;Insufficient funds&#34;)) (define (deposit amount) (begin (set! balance (+ balance amount)) balance)) (define (dispatch pass m) (if (eq? pass password) (cond ((eq? m &#39;withdraw) withdraw) ((eq? m &#39;deposit) deposit) (else (error &#34;Unknown request -- MAKE-ACCOUNT&#34; m))) (lambda (...args) (set! times (- times 1)) (if (&lt;= times 0) (call-the-cops) &#34;Incorrect password&#34;)))) dispatch)) ;&gt;&gt;&gt; (define acc (make-account 100 &#39;752)) ;&gt;&gt;&gt; ((acc &#39;752 &#39;withdraw) 40) ;: 60 ;&gt;&gt;&gt; ((acc &#39;1 &#39;withdraw) 30) ;: &#34;Incorrect password&#34; ;&gt;&gt;&gt; ((acc &#39;2 &#39;withdraw) 30) ;: &#34;Incorrect password&#34; ;&gt;&gt;&gt; ((acc &#39;3 &#39;withdraw) 30) ;: &#34;Incorrect password&#34; ;&gt;&gt;&gt; ((acc &#39;4 &#39;withdraw) 30) ;: &#34;Incorrect password&#34; ;&gt;&gt;&gt; ((acc &#39;5 &#39;withdraw) 30) ;: &#34;Incorrect password&#34; ;&gt;&gt;&gt; ((acc &#39;6 &#39;withdraw) 30) ;: &#34;Incorrect password&#34; ;&gt;&gt;&gt; ((acc &#39;7 &#39;withdraw) 30) ;: &#34;Cops are coming&#34; ;&gt;&gt;&gt; ((acc &#39;8 &#39;withdraw) 30) ;: &#34;Cops are coming&#34; ;&gt;&gt;&gt; ((acc &#39;9 &#39;withdraw) 30) ;: &#34;Cops are coming&#34; 练习 5 蒙特卡罗积分是一种通过蒙特卡罗模拟估计定积分值的方法。考虑由谓词 $P(x, y)$ 描述的一个区域的面积计算问题，该谓词对于此区域内部的点 $(x, y)$ 为真，对于不在区域内的点为假。举例来说，包含在以 $(5, 7)$ 为圆心半径为 $3$ 的圆圈所围成的区域，可以用检查公式 $(x - 5)^2 + (y - 7)^2 \le 3^2$ 是否成立的谓词描述。要估计这样一个谓词所描述的区域的面积，我们应首先选取一个包含该区域的矩形。例如，以 $(2, 4)$ 和 $(8, 10)$ 作为对角点的矩形包含着上面的圆。需要确定的积分也就是这一矩形中位于所关注区域内的那个部分。我们可以这样估计积分值：随机选取位于矩形中的点 $(x, y)$，对每个点检查 $P(x, y)$，确定该点是否位于所考虑的区域内。如果试了足够多的点 $(x, y)$，那么落在区域内的点的比率将能给出矩形中有关区域的比率。这样，用这一比率去乘整个矩形的面积，就能得到相应积分的一个估计值。
将蒙特卡罗积分实现为一个过程 estimate-integral，它以一个谓词 P，矩形的上下边界 x1、x2、y1 和 y2，以及为产生估计值而要求试验的次数作为参数。你的过程应该使用上面用于估计 $\pi$ 值的同一个 monte-carlo 过程。请用你的 estimate-integral，通过对单位圆面积的度量产生出 $\pi$ 的一个估计值。
你可能发现，有一个从给定区域中选取随机数的过程非常有用。下面的 random-in-range 过程利用 1.2.6 节 里使用的 random 实现这一工作，它返回一个小于其输入的非负数。
1 2 3 (define (random-in-range low high) (let ((range (- high low))) (+ low (random range)))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #lang sicp (define (random-in-range low high) (let ((range (- high low))) (+ low (random range)))) (define (unit-circle-test) (let ((x (random-in-range -1.0 1.0)) (y (random-in-range -1.0 1.0))) (&lt; (+ (* x x) (* y y)) 1))) (define (monte-carlo trials experiment) (define (iter trials-remaining trials-passed) (cond ((= trials-remaining 0) (/ trials-passed trials)) ((experiment) (iter (- trials-remaining 1) (+ trials-passed 1))) (else (iter (- trials-remaining 1) trials-passed)))) (iter trials 0)) ;&gt;&gt;&gt; (* 4.0 (monte-carlo 100 unit-circle-test)) ;: 3.28 ;&gt;&gt;&gt; (* 4.0 (monte-carlo 1000 unit-circle-test)) ;: 3.076 ;&gt;&gt;&gt; (* 4.0 (monte-carlo 10000 unit-circle-test)) ;: 3.1144 ;&gt;&gt;&gt; (* 4.0 (monte-carlo 100000 unit-circle-test)) ;: 3.14748 ;&gt;&gt;&gt; (* 4.0 (monte-carlo 1000000 unit-circle-test)) ;: 3.146112 ;&gt;&gt;&gt; (* 4.0 (monte-carlo 10000000 unit-circle-test)) ;: 3.1423176 练习 6 有时也需要能重置随机数生成器，以便从某个给定值开始生成随机数序列。请重新设计一个 rand 过程，使得我们可以用符号 generate 或者符号 reset 作为参数去调用它。其行为是：(rand 'generate) 将产生出一个新随机数，((rand 'reset) &lt;new-value&gt;) 将内部状态变量重新设置为指定的值 &lt;new-value&gt;。通过这样重置状态，我们就可以重复生成同样的序列。在使用随机数测试程序，排除其中错误时，这种功能非常有用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #lang sicp (define random-init 0) (define (rand-update x) (+ x 1)) (define rand (let ((x random-init)) (define (generate) (set! x (rand-update x)) x) (define (reset init) (set! x init)) (define (dispatch message) (cond ((eq? message &#39;generate) (generate)) ((eq? message &#39;reset) reset) (else (error &#34;Unknown request -- RAND&#34; message)))) dispatch)) ;&gt;&gt;&gt; (rand &#39;generate) ;: 1 ;&gt;&gt;&gt; (rand &#39;generate) ;: 2 ;&gt;&gt;&gt; (rand &#39;generate) ;: 3 ;&gt;&gt;&gt; ((rand &#39;reset) 752) ;&gt;&gt;&gt; (rand &#39;generate) ;: 753 ;&gt;&gt;&gt; (rand &#39;generate) ;: 754 ;&gt;&gt;&gt; (rand &#39;generate) ;: 755 练习 7 考虑如 练习 3 所描述的，由 make-account 创建的带有密码的银行账户对象。假定我们的银行系统中需要一种提供共用账户的能力。请定义过程 make-joint 创建这种账户。make-joint 应该有三个参数：第一个是有密码保护的账户；第二个参数是一个 密码，它必须与那个已经定义的账户的密码匹配，以使 make-joint 操作能够继续下去；第三个参数是新密码。make-joint 用这一新密码创建起对那个原有账户的另一访问途径。例如，如果 peter-acc 是一个具有密码 open-sesame 的银行账户，那么
1 2 (define paul-acc (make-joint peter-acc &#39;open-sesame &#39;rosebud)) 将使我们可以通过名字 paul-acc 和密码 rosebud 对账户 peter-acc 做现金交易。你可能希望修改自己对 练习 3.3 的解，加入这一新功能。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #lang sicp (define (make-account balance password) (define (withdraw amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) &#34;Insufficient funds&#34;)) (define (deposit amount) (begin (set! balance (+ balance amount)) balance)) (define (check-password pass) (if (eq? pass password) #t #f)) (define (dispatch pass m) (if (eq? m &#39;check-password) (check-password pass) (if (check-password pass) (cond ((eq? m &#39;withdraw) withdraw) ((eq? m &#39;deposit) deposit) (else (error &#34;Unknown request -- MAKE-ACCOUNT&#34; m))) (lambda (arg . args) &#34;Incorrect password&#34;)))) dispatch) (define (make-joint account password my-password) (if (account password &#39;check-password) (lambda (pass m) (if (eq? pass my-password) (account password m) (lambda (arg . args) &#34;Incorrect user password&#34;))) (lambda (arg . args) &#34;Incorrect admin password&#34;))) (define peter-acc (make-account 100 &#39;open-sesame)) (define paul-acc (make-joint peter-acc &#39;open-sesame &#39;rosebud)) (define bob-acc (make-joint peter-acc &#39;pass &#39;haha)) ;&gt;&gt;&gt; (bob-acc &#39;test &#39;test) ;: &#34;Incorrect admin password&#34; ;&gt;&gt;&gt; ((peter-acc &#39;open-sesame &#39;withdraw) 50) ;: 50 ;&gt;&gt;&gt; ((peter-acc &#39;open-sesame &#39;deposit) 50) ;: 100 ;&gt;&gt;&gt; ((paul-acc &#39;rosebud &#39;withdraw) 40) ;: 60 ;&gt;&gt;&gt; ((paul-acc &#39;rosebud &#39;withdraw) 40) ;: 20 ;&gt;&gt;&gt; ((paul-acc &#39;rosebud &#39;withdraw) 40) ;: &#34;Insufficient funds&#34; ;&gt;&gt;&gt; ((paul-acc &#39;open-sesame &#39;withdraw) 40) ;: &#34;Incorrect user password&#34; ;&gt;&gt;&gt; ((peter-acc &#39;open-sesame &#39;deposit) 50) ;: 70 练习 8 在 1.1.3 节 定义求值模型时我们说过，求值一个表达式的第一步就是求值其中的子表达式。但那时并没有说明应该按怎样的顺序对这些子表达式求值（例如，是从左到右还是从右到左）。当我们引进了赋值之后，对一个过程的各个参数的求值顺序不同就可能导致不同的结果。请定义一个简单的过程 f，使得 (+ (f 0) (f 1)) 的求值在对实际参数采用从左到右的求值顺序时返回 0，而对实际参数采用从右到左的求值顺序时返回 1。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #lang sicp (define (f-builder flag) (lambda (x) (begin (set! flag (- flag 1)) (* x flag)))) ;&gt;&gt;&gt; (define f (f-builder 2)) ;&gt;&gt;&gt; (define ff (f-builder 2)) ;&gt;&gt;&gt; (+ (f 0) (f 1)) ;: 0 ;&gt;&gt;&gt; (+ (ff 1) (ff 0)) ;: 1 练习 9 在 1.2.1 节 里，我们用代换模型分析了两个计算阶乘的函数，递归版本：
1 2 3 4 (define (factorial n) (if (= n 1) 1 (* n (factorial (- n 1))))) 和迭代版本：
1 2 3 4 5 6 7 8 9 (define (factorial n) (fact-iter 1 1 n)) (define (fact-iter product counter max-count) (if (&gt; counter max-count) product (fact-iter (* counter product) (+ counter 1) max-count))) 请说明采用过程 factorial 的上述版本求值 (factorial 6) 时所创建的环境结构。
练习 10 在 make-withdraw 过程里，局部变量 balance 是作为 make-withdraw 的参数创建的。我们也可以显式地通过使用 let 创建局部状态变量，就像下面所做的：
1 2 3 4 5 6 7 (define (make-withdraw initial-amount) (let ((balance initial-amount)) (lambda (amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) &#34;Insufficient funds&#34;)))) 请重温 1.3.2 节，let 实际上是一个过程调用的语法糖衣：
1 (let ((&lt;var&gt; &lt;exp&gt;)) &lt;body&gt;) 它将被解释为
1 ((lambda (&lt;var&gt;) &lt;body&gt;) &lt;exp&gt;) 的另一种语法形式。请用环境模型分析 make-withdraw 的这个版本，画出像上面那样的图示，说明调用：
1 2 3 4 5 (define W1 (make-withdraw 100)) (W1 50) (define W2 (make-withdraw 100)) 时的情况并阐释 make-withdraw 的这两个版本创建出的对象具有相同的行为。两个版本的环境结构有什么不同吗？
]]></content></entry><entry><title>远程工作方式</title><url>/post/remote-work/2020/</url><categories><category>Work</category></categories><tags><tag>Remote</tag><tag>SSH</tag><tag>Proxy</tag></tags><content type="html"><![CDATA[SSH 代理 从 SSH 说起，基本的使用就不说了，首先介绍它支持的三种代理方式（在 Unix-like 环境下基本都可以用 man ssh 查到）。
本地代理 1 ssh -L [&lt;本机地址&gt;:]&lt;本机端口&gt;:&lt;服务器地址1&gt;:&lt;服务器端口&gt; &lt;用户&gt;@&lt;服务器地址2&gt; [-p &lt;服务器 SSH 端口&gt;] （&lt;x&gt; 表示变量，[x] 是可选参数）
&lt;本机地址&gt; 默认为 127.0.0.1 或 localhost
&lt;服务器 SSH 端口&gt; 默认为 22
这会将 &lt;本机地址&gt;:&lt;本机端口&gt; 网络请求转发到 &lt;服务器地址1&gt;:&lt;服务器端口&gt; 。
下面用 MobaXterm 带的 Cygwin 环境看看具体用途：
首先直接 SSH 登录服务器：
1 ssh root@baitian.xyz 在当前目录新建一个 index.html 文件，用来测试 Web 访问，内容如下：
1 &lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello Boy!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 启动一个 HTTP 服务：
1 python3 -m http.server --bind 172.17.0.1 8000 这会在 172.17.0.1:8000 以当前目录启动 HTTP 服务，我的服务器公网地址是 baitian.xyz，但我的服务器无法将 HTTP 服务绑定到这个地址，因为公网地址是云服务器提供商那一层绑定的，我的服务器用 ip a 或是 ifconfig 等命令都看不到公网地址（如果是直接在公网开启 HTTP 服务，并配置好防火墙规则，是可以直接用公网访问的，其实我用内网 192.168.1.116 地址就会直接绑定到公网，当然，这都是提供商做的映射）。
此时，我在本机用地址 http://172.17.0.1:8000 访问 HTTP 服务：
其实，这是不该有的操作，172.*.*.* 这个是内网地址，不在同一网段是无法直接访问的，但也别太拘泥于什么内网，外网/公网的，本文的目的就是模糊这些，消除访问限制。
开启本地代理：
1 ssh -L 8000:172.17.0.1:8000 root@baitian.xyz 然后：
这就是本地代理。
(如果按 &lt;Ctrl + D&gt; 无法断开 SSH 代理的连接，请先关闭浏览器窗口)
反向代理 1 ssh -R [&lt;forward ip&gt;:]&lt;forward port&gt;:&lt;local ip&gt;:&lt;local port&gt; &lt;user&gt;@&lt;server&gt; [-p &lt;server SSH port&gt;] 和前面的本地代理的区别只是本机和转发的 IP 及端口调换了，也即反向代理，相对地把那个本地代理叫正向代理也成。
这可以将服务器 &lt;forward ip&gt;:&lt;forward port&gt; 的请求转发到本机 &lt;local ip&gt;:&lt;local port&gt;，但本机一般是 PC，不开什么服务的，所以使用得较本地代理更少，一般就是用来“穿墙”的：登录到学校内部的电脑、公司内部的电脑、操作家里的玩意儿。
下面模拟一下具体使用：
这是我在自己电脑上启动的一个 Ubuntu 容器的网络情况，在没有任何设置的情况下我连不上，包括任何网络请求。由于容器类型设置的 Windows Container，网关也无法访问。
Ubuntu 容器反向代理连接服务器：
1 ssh -R 192.168.1.116:8000:127.0.0.1:22 root@baitian.xyz 确保服务器的 8000 端口没有被防火墙拦截，最简单的方式是（但是得安装 ufw，没有的话可以用 iptables；如果是云服务器/VPS 的话，厂商可能还存在一层防火墙，注意在服务器后台管理设置相应安全组规则）：
1 ufw allow 8000 以及服务器的 SSH 配置 /etc/ssh/sshd_config 存在以下配置（修改配置后得重启 SSH 服务）：
1 GatewayPorts yes 此时便可通过服务器连接到 Ubuntu 容器：
1 ssh root@baitian.xyz -p 8000 (注：我的服务器内网地址 192.168.1.116 是直接和公网地址 baitian.xyz 在上层映射的，Ubuntu 容器要么配置允许 root 用户密码登录并设置密码，要么设置秘钥对登录。)
动态端口映射（Socks 代理） 1 ssh -D [&lt;local ip&gt;:]&lt;local port&gt; &lt;user&gt;@&lt;server&gt; [-p &lt;server SSH port&gt;] 这会在本地 &lt;local ip&gt;:&lt;local port&gt; 开启一个 Socks 5 代理，代理服务器为 SSH 连接的服务器。
再看本地代理中的例子：
开启 Socks 代理：
1 ssh -D 1080 root@baitian.xyz 本地 127.0.0.1:1080 为 Socks 5 代理。
开启 HTTP 服务：
1 python3 -m http.server --bind 192.168.1.116 8001 浏览器配置代理：
Microsoft Edge (Chromium) Google Chrome Mozilla Firefox 不建议命令行那么使用代理，命令行那样启动的话，比如 Chrome，得先把 Chrome 的所有窗口关掉，Edge 也是（这里是新版的 Edge，和 Chrome 差不多，旧版 Edge 在更新的 Windows 10 会消失），有条件可以使用 SwitchyOmega 插件（需要 FQ）。
远程桌面 SSH X Server/Client 我以前对这个的客户端和服务端的理解是反的，其实这一套里面自己的 PC 一般充当服务端，服务器充当客户端，服务器调用 PC 的服务。
所以，直接使用原生 SSH 提供的 X（可以叫 X11）转发的话 PC 需要安装 X Server，可以安装 VcXsrv ，安装好后启动。先设置好 DISPLAY 环境变量，然后 SSH 连接服务器。
1 ssh -Y root@baitian.xyz Windows 用户推荐使用 MobaXterm 作为 SSH 客户端，集成了 X Server，可以方便使用，也可以开各种隧道（也就是前文所说的代理）。 VNC 我已经好久没用过了，就不写了，网上也有许多资料。
TeamViewer 我没用过，就不说了。
但我知道这个可以穿透内网，这是很大的一个优势，VNC 可能需要结合代理才行。
RDP Windows 下的远程桌面，使用 Windows 服务器可能会用到
对于这些方式的优劣我没有什么见解，只知道网络好的话都没问题，网络不行都有问题&hellip;
远程开发 看到这里，我想你肯定是一名程序员吧，如果你还没用过 Visual Studio Code (VSC)，我强烈推荐你使用，因为这一节都是它，希望你能体会到它的好用。
安装插件 Remote Development。
这个插件包含三种远程连接方式：
SSH (OpenSSH Server) Container (Docker) WSL (Windows Subsystem for Linux) VSC SSH 远程主机 首先，需要了解一个叫 SSH Config 的东西, 其实很简单，就是规定了 SSH 连接的配置，不用连接时指定那么多参数。
比如，我在 C:\Users\baitian\.ssh\config 文件存在配置（注意，用户名用自己的）：
1 2 3 4 5 Host aliyun HostName baitian.xyz Port 22 User root IdentityFile ~/.ssh/baitian752 我就可以直接通过命令 ssh aliyun 连接到我的阿里云服务器了。
同时，VSC 的远程插件可以识别出配置的远程主机：
连接上去，左下角显示 SSH: aliyun 表示连接成功（第一次连接时由于要安装服务端时间会久一些）：
打开一个远程项目，然后，所有操作如本地一般：
如果要使用 X Server，修改 C:\Users\baitian\.ssh\config 如下：
1 2 3 4 5 6 7 Host aliyun HostName baitian.xyz Port 22 User root IdentityFile ~/.ssh/baitian752 ForwardX11 yes ForwardX11Trusted yes 配置好 DISPLAY 环境变量，启动 VcXsrv，重新打开项目。此时，便可在服务器通过 X Client 在本地显示图形界面：
VSC Docker 容器 连接本机的 Docker 容器，但这种玩儿法在 Windows 下对内存需求比较高，估计 12GB 及以上才能比较爽，和上面相比一方面是 Docker 的优势，另一方面是带宽，毕竟这是在本机。
VSC WSL 我目前不推荐使用 WSL，因为 WSL 系统有诸多限制，和容器差不多的，比如，基于 systemctl 服务是跑不了的（和系统的启动方式有关，这是很底层的东西了，我没有什么了解），和 Docker 相比还有一个巨大的不足，磁盘 I/O 巨慢。也听闻 WSL 2 许久了，测试过一次，还是没感觉好用，而且需要预览版 Windows 10 才能体验 WSL 2。
我的观点是，内存足够的话，目前完全没必要使用 WSL，Docker 的各方面体验都比 WSL 好；内存不够的话，用 SSH 连接远程主机吧，不用图形界面的话对网络带宽要求也不高。
Web 服务 以上提到的各种方式，其实对 Web 服务是最友好的，因为浏览器是一个天然的图形界面，服务器发送数据，浏览器进行渲染就行了，可以降低许多传输带宽。设置好代理（浏览器也可以很方便设置代理），此刻，你便会感觉犹如本地开发一样。
比如，用过 Anaconda 的对 Jupyter Notebook 大都不陌生吧，这便是一个浏览器端的应用【这是一个很强大的应用，可以安装许多被称之为 kernel 的模块，可以在线使用 C/C++, Wolfram Mathematica, gnuplot, Octave, R 等等好多好多语言】；再比如，OverLeaf，一个在线的 LaTeX IDE（用过之后我就再没碰过 TexLive 了）。
其他用法 配置 SSH 为长连接 默认情况下，SSH 连接长时间没发送数据的话会自动断开，可以在服务器的 /etc/ssh/sshd_config 作如下配置：
1 2 ClientAliveInterval 60 ClientAliveCountMax 3 这样配置每过 60 秒会发送一个数据包，保持连接为活动状态，当然也可以在客户端配置（就我个人而言，客户端是远多于服务端的，所以一般在服务端配置更省事）C:\Users\baitian\.ssh\config ：
1 2 3 4 5 6 7 Host aliyun HostName baitian.xyz Port 22 User root IdentityFile ~/.ssh/baitian752 ServerAliveInterval 60 ServerAliveCountMax 3 暂时使用：
1 ssh &lt;user&gt;@&lt;server&gt; -o ServerAliveInterval=60 -o ServerAliveCountMax=3 搭建公共代理 服务器自己 SSH 连接自己开启动态端口映射：
1 ssh -D &lt;public ip&gt;:&lt;port&gt; &lt;user&gt;@127.0.0.1 同时防火墙开启服务器的 &lt;port&gt; 端口，能够访问公网的机器便都可以使用 &lt;public ip&gt;:&lt;port&gt; 作为 Socks 5 代理了。
这里公网只是相对的，比如我自己电脑经过路由器后 IP 为 192.168.1.8，那么，我通过以下方式：
1 ssh -D 192.168.1.8:1080 &lt;user&gt;@&lt;server ip&gt; 可以在自己电脑所属的路由器子网搭建一个 Socks 5 代理（192.168.1.8:1080），便可局限在一个相对小的范围内共享 &lt;server ip&gt; 的网络了。
结合 SSH 长连接，可以搭建一个持久化的代理。 SSH 跳板机登录 有时候存在以下情况：只能通过跳板机 &lt;server1&gt; 连接其他服务器（比如 &lt;server2&gt;），而 &lt;server1&gt; 的权限给的很低，路由，SSH 配置都不能修改。
此时，想直接登录 &lt;server2&gt;，可以用前面提到的反向代理方式，但这种方式需要一台有 root 权限（需要修改 SSH 服务端配置）的公网服务器，所示处理这种情况并不好。
SSH 本身就支持跳板登录:
1 ssh -J &lt;user1&gt;@&lt;server1&gt; &lt;user2&gt;@&lt;server2&gt; 这会登录到 &lt;server2&gt;，如果配置上代理，代理服务器是 &lt;server2&gt; 。
当然，还可以使用 &lt;server1&gt; 作为代理服务器，连接 &lt;server2&gt;：
1 ssh &lt;user2&gt;@&lt;server2&gt; -o ProxyCommand=&#34;ssh.exe -W %h:%p &lt;user1&gt;@&lt;server1&gt;&#34; 如果是 Windows 10 自带的 OpenSSH 客户端，注意里面的 ssh.exe 不能改成 ssh；DISPLAY 环境变量也可能导致错误，需要时删除该环境变量，或者使用 Git for Windows 的 SSH 客户端，或是 MSYS2 的 SSH 客户端（未测试）；最好是配置 SSH 秘钥对登录，更安全、省事，如果实在是无法配置秘钥对，又不想手动输入密码，可以考虑 sshpass。 ]]></content></entry><entry><title>Ubuntu 18.04 通过 Kolla Ansible 部署多节点 OpenStack Stein</title><url>/post/openstack/ubuntu-18-04-kolla-ansible-deploy-openstack-stein-multinode/</url><categories><category>Work</category></categories><tags><tag>OpenStack</tag><tag>Python</tag><tag>Shell</tag></tags><content type="html"><![CDATA[Virtual Box 安装 Ubuntu 18.04 Live Server 安装 3 台 Ubuntu 18.04，各配置一块 NAT 网卡和一块仅主机 (Host Only) 网卡，3 台的仅主机网络用同一个 Virtual Box 的虚拟网卡。主机名及 IP 如下：
1 2 3 controller: 192.168.56.10 compute1: 192.168.56.20 compute2: 192.168.56.30 准备工作（controller，compute1，compute2） 配置访问更快的 apt 源，pip 源（清华、阿里等） 安装 pip 1 apt install python-pip -y 更新 pip 1 pip install -U pip 安装 Docker 1 apt install docker.io -y 安装部署工具（controller） 安装依赖 1 apt install python-dev libffi-dev gcc libssl-dev python-selinux python-setuptools -y 安装 ansible 1 pip install ansible 安装 kolla ansible 1 git clone http://git.trystack.cn/openstack/kolla-ansible.git --branch stable/stein --depth 1 $HOME/kolla-ansible 上面使用了 OpenStack 国内 git 镜像 安装 kolla ansible 依赖 1 pip install -U -r $HOME/kolla-ansible/requirements.txt 配置 Hosts（controller，compute1，compute2）（/etc/hosts） 注释掉主机名到 127.0.1.1 的映射 添加节点信息（controller） 1 2 3 192.168.56.10 controller 192.168.56.20 compute1 192.168.56.30 compute2 配置 kolla （controller） 拷贝全局配置 globals.yml 和密码配置 passwords.yml 1 cp -r $HOME/kolla-ansible/etc/kolla /etc/ 拷贝多节点配置文件 multinode 1 cp $HOME/kolla-ansible/ansible/inventory/multinode $HOME/ 生成随机密码 1 $HOME/kolla-ansible/tools/generate_passwords.py 配置 globals.yml，添加以下内容（/etc/kolla/globals.yml） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 kolla_dev_repos_git: &#34;http://git.trystack.cn/openstack&#34; config_strategy: &#34;COPY_ONCE&#34; kolla_base_distro: &#34;ubuntu&#34; kolla_install_type: &#34;source&#34; openstack_release: &#34;stein&#34; kolla_internal_vip_address: &#34;controller&#34; network_interface: &#34;enp0s8&#34; # Host Only network interface neutron_external_interface: &#34;enp0s3&#34; # NAT network interface node_custom_config: &#34;/etc/kolla/config&#34; enable_haproxy: &#34;no&#34; enable_cinder: &#34;yes&#34; enable_cinder_backend_lvm: &#34;yes&#34; enable_etcd: &#34;yes&#34; enable_kuryr: &#34;yes&#34; enable_zun: &#34;yes&#34; enable_neutron_provider_networks: &#34;yes&#34; enable_osprofiler: &#34;yes&#34; enable_skydive: &#34;yes&#34; enable_elasticsearch: &#34;yes&#34; enable_aodh: &#34;yes&#34; enable_gnocchi: &#34;yes&#34; enable_panko: &#34;yes&#34; enable_ceilometer: &#34;yes&#34; enable_octavia: &#34;yes&#34; nova_compute_virt_type: &#34;qemu&#34; # Must set this when deploying in virtual machines 配置多节点信息（./multinode） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [control] controller ansible_ssh_user=root [network] controller ansible_ssh_user=root [compute] controller ansible_ssh_user=root compute1 ansible_ssh_user=root compute2 ansible_ssh_user=root [monitoring] controller ansible_ssh_user=root [storage] controller ansible_ssh_user=root compute1 ansible_ssh_user=root compute2 ansible_ssh_user=root 在配置了 storage 的节点上挂载一块硬盘（controller, conpute1, compute2） 这里假设设备为 /dev/sdb 1 2 3 free_device=/dev/sdb pvcreate $free_device vgcreate cinder-volumes $free_device 配置 SSH 密钥登录各节点，并确认主机指纹验证 测试多节点配置 1 ansible -i $HOME/multinode all -m ping 额外配置 chrony 绑定地址，/etc/kolla/config/chrony/chrony.conf
1 bindaddress 192.168.56.10 nova compute monitors，/etc/kolla/config/nova/nova.conf
1 2 [DEFAULT] compute_monitors = cpu.virt_driver octavia 配置 SSL 证书
克隆 octavia git 仓库
1 git clone http://git.trystack.cn/openstack/octavia.git --branch stable/stein --depth 1 $HOME/octavia 生成 SSL 证书
1 2 3 4 grep octavia_ca_password /etc/kolla/passwords.yml (这行是输出）octavia_ca_password: &lt;octavia_ca_password&gt; sed -i &#39;s/foobar/&lt;octavia_ca_password&gt;/g&#39; $HOME/octavia/bin/create_certificates.sh $HOME/octavia/bin/create_certificates.sh certs $HOME/octavia/etc/certificates/openssl.cnf 拷贝 SSL 证书
1 cp $HOME/certs/ca_01.pem certs/client.pem $HOME/certs/private/cakey.pem /etc/kolla/config/octavia/ 获取 kolla 镜像（controller） 配置 Docker 仓库代理（可选） 在 /etc/docker/daemon.json 中添加
1 2 3 { &#34;registry-mirrors&#34;: [&#34;https://docker.mirrors.sjtug.sjtu.edu.cn&#34;] } 重载 daemon，重启 docker
1 2 systemctl daemon-reload systemctl restart docker 方式1，从 Docker Hub 拉取 1 $HOME/kolla-ansible/tools/kolla-ansible pull -vvv 方式2，本地 tar 导入 搭建本地 registry 服务器 1 docker run -d --name registry --restart=always -p 4000:5000 -v /opt/registry:/var/lib/registry registry 修改镜像 tag 1 for item in `docker images | grep stein | awk &#39;{print $1}&#39;`; do docker image tag $item:stein controller:4000/$item:stein; done 配置 kolla 使用本地 registry 服务器 在 /etc/kolla/globals.yml 中添加
1 docker_registry: &#34;controller:4000&#34; Kolla Ansible Bootstrap Servers（controller） 1 $HOME/kolla-ansible/tools/kolla-ansible -i $HOME/multinode bootstrap-servers 拉取镜像至各节点（controller） 上传镜像至本地 registry 服务器 1 for item in `docker images | grep controller:4000 | awk &#39;{print $1}&#39;`; do docker push $item:stein; done 拉取镜像至各节点 1 $HOME/kolla-ansible/tools/kolla-ansible -i $HOME/multinode pull 各节点配置 ZUN Compute 容器（controller，compute1，compute2） 修改 /etc/systemd/system/docker.service.d/kolla.conf
将
1 ExecStart=/usr/bin/dockerd --insecure-registry controller:4000 --log-opt max-file=5 --log-opt max-size=50m 分别修改为
(controller)
1 ExecStart=/usr/bin/dockerd --insecure-registry controller:4000 --log-opt max-file=5 --log-opt max-size=50m -H tcp://controller:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://controller:2379 (compute1)
1 ExecStart=/usr/bin/dockerd --insecure-registry controller:4000 --log-opt max-file=5 --log-opt max-size=50m -H tcp://compute1:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://controller:2379 (compute2)
1 ExecStart=/usr/bin/dockerd --insecure-registry controller:4000 --log-opt max-file=5 --log-opt max-size=50m -H tcp://compute2:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://controller:2379 重载 daemon，重启 docker （controller，compute1，compute2）
1 2 systemctl daemon-reload systemctl restart docker Kolla Ansible Pre-Checks（controller） 1 $HOME/kolla-ansible/tools/kolla-ansible -i $HOME/multinode prechecks Kolla Ansible Deploy（controller） 1 $HOME/kolla-ansible/tools/kolla-ansible -i $HOME/multinode deploy Kolla Ansible Post Deploy（controller） 1 $HOME/kolla-ansible/tools/kolla-ansible -i $HOME/multinode post-deploy 初始化配置（controller） 安装 OpenStack 客户端（建议在虚拟环境进行） 1 pip install python-openstackclient 配置管理员环境 1 . /etc/kolla/admin-openrc.sh 拷贝初始化脚本 1 cp $HOME/kolla-ansible/tools/init-runonce $HOME/ 配置初始化脚本 （./init-runonce） 1 2 3 EXT_NET_CIDR=&#39;10.0.2.0/24&#39; EXT_NET_RANGE=&#39;start=10.0.2.100,end=10.0.2.199&#39; EXT_NET_GATEWAY=&#39;10.0.2.2&#39; 执行初始化脚本 1 . $HOME/init-runonce 配置 br-ex 桥接网卡 （/etc/network/interfaces） 1 2 3 4 5 auto br-ex iface br-ex inet static address 10.0.2.200 netmask 255.255.255.0 gateway 10.0.2.2 重启网络 1 netplan apply 额外配置（controller） Horizon 管理员环境 将 admin-openrc.sh，prediction_train.csv，model.m 拷贝至 horizon 容器并修改权限
1 2 3 docker cp /etc/kolla/admin-openrc.sh horizon:/etc/openstack-dashboard/ docker cp $HOME/prediction_train.csv horizon:/etc/openstack-dashboard/ docker cp $HOME/model.m horizon:/etc/openstack-dashboard/ 1 2 3 docker exec horizon chown horizon:horizon /etc/openstack-dashboard/admin-openrc.sh docker exec horizon chown horizon:horizon /etc/openstack-dashboard/prediction_train.csv docker exec horizon chown horizon:horizon /etc/openstack-dashboard/model.m 重启 horizon 容器
1 docker restart horizon octavia 配置 创建 amphora 镜像（可在 https://tarballs.openstack.org/octavia/test-images/ 下载）
1 openstack image create --disk-format qcow2 --file $HOME/test-only-amphora-x64-haproxy-ubuntu-bionic.qcow2 --tag amphora amphora 创建 octavia 安全组
1 openstack security group create --description &#39;Used by octavia amphora instance&#39; octavia 为安全组添加规则
（&lt;security_group_id&gt; 通过 openstack security group list 获取）
1 2 3 openstack security group rule create --protocol icmp &lt;security_group_id&gt; openstack security group rule create --protocol tcp --dst-port 5555 --egress &lt;security_group_id&gt; openstack security group rule create --protocol tcp --dst-port 9443 --ingress &lt;security_group_id&gt; 添加密钥对
（&lt;octavia_keystone_password&gt; 通过 grep octavia_keystone_password /etc/kolla/passwords.yml 获取）
1 2 openstack keypair create --public-key $HOME/.ssh/id_rsa.pub octavia_ssh_key openstack --os-username octavia --os-password &lt;octavia_keystone_password&gt; keypair create --public-key $HOME/.ssh/id_rsa.pub octavia_ssh_key 修改 /etc/kolla/octavia-worker/octavia.conf
（&lt;network_id&gt; 通过 openstack network list 获取，选择 public1 的 ID）
（&lt;flavor_id&gt; 通过 openstack flavor list 获取）
1 2 3 4 5 6 [controller_worker] amp_boot_network_list = &lt;network_id&gt; amp_image_tag = amphora amp_secgroup_list = octavia amp_flavor_id = &lt;flavor_id&gt; amp_ssh_key_name = octavia_ssh_key 重启 octavia_worker 容器
1 docker restart octavia_worker ]]></content></entry><entry><title>Learn SICP Chapter 2</title><url>/post/sicp/learn-sicp-ch2/</url><categories><category>Learn</category></categories><tags><tag>Scheme</tag><tag>SICP</tag></tags><content type="html"><![CDATA[现在到了数学抽象中最关键的一步：让我们忘记这些符号所表示的对象。……（数学家）不应在这里停步，有许多操作可以应用于这些符号，而根本不必考虑它们到底代表着什么东西。
Hermann Weyl, The Mathematical Way of Thinking
（思维的数学方式） 练习 1 请定义出 make-rat 的一个更好的版本，使之可以正确处理正数和负数。当有理数为正时，make-rat 应当将其规范化，使它的分子和分母都是正的。如果有理数为负，那么就应只让分子为负。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #lang sicp (define (gcd m n) (if (= m 0) n (if (= n 0) m (if (&gt; m n) (gcd (- m n) n) (gcd m (- n m)))))) (define (make-rat n d) (if (= d 0) (error &#34;Denom cannot be 0&#34;) (if (= n 0) (cons 0 1) (if (and (&lt; n 0) (&lt; d 0)) (make-rat (- n) (- d)) (if (and (&lt; n 0) (&gt; d 0)) (let ((g (gcd (- n) d))) (cons (/ n g) (/ d g))) (if (and (&gt; n 0) (&gt; d 0)) (let ((g (gcd n d))) (cons (/ n g) (/ d g))) (cons (- n) (- d)))))))) (define (number x) (car x)) (define (denom x) (cdr x)) (define (add-rat x y) (make-rat (+ (* (number x) (denom y)) (* (number y) (denom x))) (* (denom x) (denom y)))) (define (sub-rat x y) (make-rat (- (* (number x) (denom y)) (* (number y) (denom x))) (* (denom x) (denom y)))) (define (mul-rat x y) (make-rat (* (number x) (number y)) (* (denom x) (denom y)))) (define (div-rat x y) (make-rat (* (number x) (denom y)) (* (number y) (denom x)))) (define (equal-rat? x y) (= (* (number x) (denom y)) (* (number y) (denom x)))) (define (print-rat x) (newline) (display (number x)) (display &#34;/&#34;) (display (denom x))) ;&gt;&gt;&gt; (make-rat 2 0) ;: Denom cannot be 0 ;&gt;&gt;&gt; (print-rat (make-rat 2 4)) ;: 1/2 ;&gt;&gt;&gt; (print-rat (make-rat -2 4)) ;: -1/2 ;&gt;&gt;&gt; (print-rat (make-rat 2 -4)) ;: -2/4 ;&gt;&gt;&gt; (print-rat (make-rat -2 -4)) ;: 1/2 ;&gt;&gt;&gt; (print-rat (add-rat (make-rat 2 4) (make-rat 4 6))) ;: 7/6 ;&gt;&gt;&gt; (print-rat (sub-rat (make-rat 2 4) (make-rat 4 6))) ;: -1/6 ;&gt;&gt;&gt; (print-rat (mul-rat (make-rat 2 4) (make-rat 4 6))) ;: 1/3 ;&gt;&gt;&gt; (print-rat (div-rat (make-rat 2 4) (make-rat 4 6))) ;: 3/4 ;&gt;&gt;&gt; (equal-rat? (make-rat 32 -128) (make-rat -13 52)) ;: #t 练习 2 请考虑平面上线段的表示问题。一个线段用一对点表示，它们分别是线段的始点与终点，请定义构造函数 make-segment 和选择函数 start-segment、end-segment，它们基于点定义线段的表示。进而，一个点可以用数的序对表示，序对的两个成分分别表示点的 $x$ 坐标和 $y$ 坐标。请据此进一步给出构造函数 make-point 和选择函数 x-point、y-point，用它们定义出点的这种表示。最后，请基于所定义的构造函数和选择函数，定义出过程 midpoint-segmant，它以一个线段为参数，返回线段的中点（也就是那个坐标值两个端点的平均值的点）。为了试验这些过程，还需要定义一种打印点的方法：
1 2 3 4 5 6 7 (define (print-point p) (newline) (display &#34;(&#34;) (display (x-point p)) (display &#34;,&#34;) (display (y-point p)) (display &#34;)&#34;)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #lang sicp (define (print-point p) (newline) (display &#34;(&#34;) (display (x-point p)) (display &#34;,&#34;) (display (y-point p)) (display &#34;)&#34;)) (define (make-point x y) (cons x y)) (define (x-point p) (car p)) (define (y-point p) (cdr p)) (define (make-segment p q) (cons p q)) (define (start-segment s) (car s)) (define (end-segment s) (cdr s)) (define (midpoint-segment s) (let ((p (start-segment s)) (q (end-segment s))) (cons (/ (+ (x-point p) (x-point q)) 2) (/ (+ (y-point p) (y-point q)) 2)))) ;&gt;&gt;&gt; (define p (make-point 1 2)) ;&gt;&gt;&gt; (define q (make-point 3 4)) ;&gt;&gt;&gt; (print-point p) ;: (1,2) ;&gt;&gt;&gt; (define s (make-segment p q)) ;&gt;&gt;&gt; (define m (midpoint-segment s)) ;&gt;&gt;&gt; (print-point m) ;: (2,3) 练习 3 请实现一种平面矩形的表示（提示：你有可能借用 练习 2 的结果）。基于你的构造函数和选择函数定义几个过程，计算给定矩形的周长和面积等。现在请再为矩形实现另一种表示方式。你应该怎样设计系统，使之能提供适当的抽象屏蔽，使同一个周长或者面积过程对两种不同表示都能工作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #lang sicp (define (make-point x y) (cons x y)) (define (x-point p) (car p)) (define (y-point p) (cdr p)) (define (make-rect origin angle width height) (cons (cons origin angle) (cons width height))) (define (origin-rect r) (car (car r))) (define (angle-rect r) (cdr (car r))) (define (width-rect r) (car (cdr r))) (define (height-rect r) (cdr (cdr r))) (define (perimeter-rect r) (* 2 (+ (width-rect r) (height-rect r)))) (define (area-rect r) (* (width-rect r) (height-rect r))) ;&gt;&gt;&gt; (define r (make-rect (make-point 0 0) 1.57 2 3)) ;&gt;&gt;&gt; (perimeter-rect r) ;: 10 ;&gt;&gt;&gt; (area-rect r) ;: 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #lang sicp (define (make-point x y) (cons x y)) (define (x-point p) (car p)) (define (y-point p) (cdr p)) (define (distance-point p q) (define (sqr x) (* x x)) (sqrt (+ (sqr (- (x-point p) (x-point q))) (sqr (- (y-point p) (y-point q)))))) (define (dot-product v1 v2) (+ (* (x-point v1) (x-point v2)) (* (y-point v1) (y-point v2)))) (define (sub-vector v1 v2) (cons (- (car v1) (car v2)) (- (cdr v1) (cdr v2)))) (define (make-rect p1 p2 p3) (let ((d (distance-point p2 p3))) (if (or (&lt; d (distance-point p1 p2)) (&lt; d (distance-point p1 p3))) (error &#34;Points should make a rectangle&#34;) (cons p1 (cons p2 p3))))) (define (width-rect r) (distance-point (car r) (car (cdr r)))) (define (height-rect r) (distance-point (car r) (cdr (cdr r)))) (define (perimeter-rect r) (* 2 (+ (width-rect r) (height-rect r)))) (define (area-rect r) (* (width-rect r) (height-rect r))) ;&gt;&gt;&gt; (define r (make-rect ; (make-point 0 0) ; (make-point 2 0) ; (make-point 0 3))) ;&gt;&gt;&gt;&gt; (perimeter-rect r) ;: 10 ;&gt;&gt;&gt; (area-rect r) ;: 6 练习 4 下面是序对的另一种过程性表示方法。请针对这一表述验证，对于任意的 x 和 y，(car (cons x y)) 都将产生出 x。
1 2 3 4 5 (define (cons x y) (lambda (m) (m x y))) (define (car z) (z (lambda (p q) p))) 对应的 cdr 应该如何定义？（提示：为了验证这一表示确实能行，请利用 1.1.5 节的代换模型。）
1 2 3 4 5 6 (car z) (z (lambda (p q) p)) ((cons x y) (lambda (p q) p)) ((lambda (m) (m x y)) (lambda (p q) p)) ((lambda (p q) p) x y) x 1 2 (define (cdr z) (z (lambda (p q) q))) 练习 5 请证明，如果将 $a$ 和 $b$ 的序对表示为乘积 $2^a 3^b$ 所对应的整数，我们就可以只用非负整数和算术运算表示序对。请给出对应的过程 cons、car 和 cdr 的定义。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #lang sicp (define (pow b n) (define (iter n r) (if (= n 0) r (iter (- n 1) (* b r)))) (iter n 1)) (define (cons x y) (* (pow 2 x) (pow 3 y))) (define (car z) (define (iter x r) (if (odd? x) r (iter (/ x 2) (+ r 1)))) (iter z 0)) (define (cdr z) (define (get-odd x) (if (odd? x) x (get-odd (/ x 2)))) (define (iter x r) (if (= x 1) r (iter (/ x 3) (+ r 1)))) (iter (get-odd z) 0)) ;&gt;&gt;&gt; (define z (cons 618 991)) ;&gt;&gt;&gt; (car z) ;: 618 ;&gt;&gt;&gt; (cdr z) ;: 991 练习 6 如果觉得将序对表示为过程还不足以令人如雷灌顶，那么请考虑，在一个可以对过程做各种操作的语言里，我们完全可以没有数（至少在只考虑非负整数的情况下），将 $0$ 和加一操作实现为：
1 2 3 4 (define zero (lambda (f) (lambda (x) x))) (define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x))))) 这一表示形式称为 Church 计数名字来源于其发明人数理逻辑学家 Alonzo Church（丘奇），$\lambda$ 演算也是他发明的。
请直接定义 one 和 two（不用 zero 和 add-1）（提示：利用代换去求值（add0-1 zero））。请给出加法过程 + 的一个直接定义（不要通过反复应用 add-1）。
定义 one，直接代入，利用 (add-1 zero)：
1 2 3 4 5 6 7 8 9 ; (define one (add-1 zero)) ; (define one ; (lambda (f) (lambda (x) (f ((zero f) x))))) ; (define one ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))) ; (define one ; (lambda (f) (lambda (x) (f ((lambda (x) x) x))))) (define one (lambda (f) (lambda (x) (f x)))) 定义 two，(add-1 one)：
1 2 3 4 5 6 7 8 9 ; (define two (add-1 one)) ; (define two ; (lambda (f) (lambda (x) (f ((one f) x))))) ; (define two ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))) ; (define two ; (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))) (define two (lambda (f) (lambda (x) (f (f x))))) n 的定义为 (add-1 n-1)：
1 2 ; (define n ; (lambda (f) (lambda (x) (f ((n-1 f) x))))) add-2 的定义为 (add-1 (add-1 n))：
1 2 3 4 5 6 7 8 9 10 11 12 ; (define (add-2 n) ; (add-1 (add-1 n))) ; (define (add-2 n) ; (add-1 (lambda (f) (lambda (x) (f ((n f) x)))))) ; (define (add-2 n) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f ((n f) x)))) f) x))))) ; (define (add-2 n) ; (lambda (f) (lambda (x) (f ((lambda (x) (f ((n f) x))) x))))) ; (define (add-2 n) ; (lambda (f) (lambda (x) (f (f ((n f) x)))))) (define (add-2 n) (lambda (f) (lambda (x) ((two f) ((n f) x))))) 假定 add-m-1 的定义为：
1 2 ; (define (add-m-1 n) ; (lambda (f) (lambda (x) ((m-1 f) ((n f) x))))) add-m 的定义为 (add-1 (add-m-1 n))：
1 2 3 4 5 6 7 8 9 10 11 12 ; (define (add-m n) ; (add-1 (add-m-1 n))) ; (define (add-m n) ; (add-1 (lambda (f) (lambda (x) ((m-1 f) ((n f) x)))))) ; (define (add-m n) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) ((m-1 f) ((n f) x)))) f) x))))) ; (define (add-m n) ; (lambda (f) (lambda (x) (f ((lambda (x) ((m-1 f) ((n f) x))) x))))) ; (define (add-m n) ; (lambda (f) (lambda (x) (f ((m-1 f) ((n f) x)))))) ; (define (add-m n) ; (lambda (f) (lambda (x) ((m f) ((n f) x))))) + 的定义为：
1 2 (define (+ m n) (lambda (f) (lambda (x) ((m f) ((n f) x))))) 练习 7 Alyssa 的程序是不完整的，因为她还没有确定区间抽象的实现。这里是区间构造符的定义：
1 (define (make-interval a b) (cons a b)) 请定义选择符 upper-bound 和 lower-bound，完成这一实现。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #lang sicp (define (make-interval a b) (cons a b)) (define (upper-bound i) (max (car i) (cdr i))) (define (lower-bound i) (min (car i) (cdr i))) ;&gt;&gt;&gt; (define i (make-interval 2 3)) ;&gt;&gt;&gt; (upper-bound i) ;: 3 ;&gt;&gt;&gt; (lower-bound i) ;: 2 ;&gt;&gt;&gt; (define i2 (make-interval 2 -3)) ;&gt;&gt;&gt; (upper-bound i2) ;: 2 ;&gt;&gt;&gt; (lower-bound i2) ;: -3 练习 8 通过类似于 Alyssa 的推理，说明两个区间的差应该怎样计算。请定义出相应的减法过程 sub-interval。
把减去区间的两个端点取相反数构造新区间，然后通过加法实现减法。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #lang sicp (define (make-interval a b) (cons a b)) (define (upper-bound i) (max (car i) (cdr i))) (define (lower-bound i) (min (car i) (cdr i))) (define (add-interval x y) (make-interval (+ (lower-bound x) (lower-bound y)) (+ (upper-bound x) (upper-bound y)))) (define (inv-interval i) (make-interval (- (lower-bound i)) (- (upper-bound i)))) (define (sub-interval x y) (add-interval x (inv-interval y))) 练习 9 区间的宽度就是其上界和下界之差的一半。区间宽度是有关区间所描述的相应数值的非确定性的一种度量。对于某些算术运算，两个区间的组合结果的宽度就是参数区间的宽度的函数，而对其他运算，组合区间的宽度则不是参数区间宽度的函数。证明两个区间的和（与差）的宽度就是被加（或减）的区间的宽度的函数。举例说明，对于乘和除而言，情况并非如此。
说明：
$I$ 表示区间 $u(I)$ 表示 $I$ 的上界 $l(I)$ 表示 $I$ 的下界 $w(I)$ 表示 $I$ 的宽度 $+, -, \times, /$ 可用于区间 $w(I)$ 的定义如下：
$$ w(I) = \frac{u(I) - l(I)}{2} $$
对于加法：
$$ u(I_1 + I_2) = u(I_1) + u(I_2) $$
$$ l(I_1 + I_2) = l(I_1) + l(I_2) $$
因此：
$$ \begin{aligned} w(I_1 + I_2) &amp;= \frac{u(I_1 + I_2) - l(I_1 + I_2)}{2} \\ &amp;= \frac{u(I_1) - l(I_1) + u(I_2) - l(I_2)}{2} \\ &amp;= w(I_1) + w(I_2) \end{aligned} $$
对于减法：
$$ \begin{aligned} w(I_1 - I_2) &amp;= w(I_1 + (-I_2)) \\ &amp;= \frac{u(I_1 + (-I_2)) - l(I_1 + (-I_2))}{2} \\ &amp;= \frac{u(I_1) - l(I_1) + u(-I_2) - l(-I_2)}{2} \\ &amp;= w(I_1) + w(I_2) \end{aligned} $$
对于乘法，要证明不是被乘区间宽度的函数，只需证明被乘区间宽度确定时，乘积区间的宽度不定。
不妨取第一个区间为 $[0, 1]$, 第二个区间分别为 $[0, 1]$、$[1, 2]$,此时，乘积区间的宽度分别为 $0.5$、$1$，因此，乘积区间的宽度不是被乘区间宽度的函数。
对于除法，证明过程与乘法类似。
练习 10 Ben Bitdiddle 是个专业程序员，他看了 Alyssa 工作后评论说，除以一个横跨 $0$ 的区间的意义不清楚。请修改 Alyssa 的代码，检查这种情况并在出现这一情况时报错。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #lang sicp (define (make-interval a b) (cons a b)) (define (upper-bound i) (max (car i) (cdr i))) (define (lower-bound i) (min (car i) (cdr i))) (define (mul-interval x y) (let ((p1 (* (lower-bound x) (lower-bound y))) (p2 (* (lower-bound x) (upper-bound y))) (p3 (* (upper-bound x) (upper-bound y))) (p4 (* (upper-bound x) (lower-bound y)))) (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4)))) (define (div-interval x y) (if (and (&gt; (upper-bound y) 0) (&lt; (lower-bound y) 0)) (error &#34;Not support interval cross 0 -- Div-Interval&#34;) (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))))) ;&gt;&gt;&gt; (define x (make-interval 1 2)) ;&gt;&gt;&gt; (define y (make-interval -1 1)) ;&gt;&gt;&gt; (div-interval x y) ;: Not support interval cross 0 -- Div-Interval ;&gt;&gt;&gt; (define x2 (make-interval 1 2)) ;&gt;&gt;&gt; (define y2 (make-interval 3 4)) ;&gt;&gt;&gt; (div-interval x2 y2) ;: (0.25 . 0.6666666666666666) 练习 11 在看了这些东西之后，Ben 又说出了下面这段有些神秘的话：“通过监测区间的端点，有可能将 mul-interval 分解为 9 中情况，每种情况中所需的乘法都不超过两次”。请根据 Ben 的建议重写这个过程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #lang sicp (define (make-interval a b) (cons a b)) (define (upper-bound i) (max (car i) (cdr i))) (define (lower-bound i) (min (car i) (cdr i))) (define (mul-interval x y) (let ((ux (upper-bound x)) (lx (lower-bound x)) (uy (upper-bound y)) (ly (lower-bound y))) (if (&lt;= ux 0) (cond ((&lt;= uy 0) (make-interval (* lx ly) (* ux uy))) ((&gt;= ly 0) (make-interval (* lx uy) (* ux ly))) (else (make-interval (* lx uy) (* lx ly)))) (if (&gt;= lx 0) (cond ((&lt;= uy 0) (make-interval (* lx uy) (* ux ly))) ((&gt;= ly 0) (make-interval (* lx ly) (* ux uy))) (else (make-interval (* ux ly) (* ux uy)))) (cond ((&lt;= uy 0) (make-interval (* lx ly) (* ux ly))) ((&gt;= ly 0) (make-interval (* lx uy) (* ux uy))) (else (make-interval (max (* lx ly) (* ux uy)) (min (* lx uy) (* ux ly))))))))) ;&gt;&gt;&gt; (define x (make-interval 1 2)) ;&gt;&gt;&gt; (define y (make-interval -1 1)) ;&gt;&gt;&gt; (mul-interval x y) ;: (-2 . 2) ;&gt;&gt;&gt; (define x2 (make-interval 1 2)) ;&gt;&gt;&gt; (define y2 (make-interval 3 4)) ;&gt;&gt;&gt; (mul-interval x2 y2) ;: (3 . 8) 练习 12 请定义一个构造函数 make-center-percent，它以一个中心点和一个百分比为参数，产生出所需要的区间。你还需要定义选择函数 percent，通过它可以得到给定区间的百分数误差，选择函数 center 与前面定义的一样。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #lang sicp (define (make-interval a b) (cons a b)) (define (upper-bound i) (max (car i) (cdr i))) (define (lower-bound i) (min (car i) (cdr i))) (define (center i) (/ (+ (lower-bound i) (upper-bound i)) 2)) (define (width i) (/ (- (upper-bound i) (lower-bound i)) 2)) (define (make-center-percent c p) (let ((w (* c p))) (make-interval (- c w) (+ c w)))) (define (percent i) (/ (width i) (center i))) ;&gt;&gt;&gt; (define i (make-center-percent 2 0.1)) ;&gt;&gt;&gt; i ;: (1.8 . 2.2) ;&gt;&gt;&gt; (center i) ;: 2.0 ;&gt;&gt;&gt; (width i) ;: 0.2 ;&gt;&gt;&gt; (percent i) ;: 0.1 练习 13 请证明，在误差为很小的百分数的条件下，存在着一个简单公式，利用它可以从两个被乘区间的误差算出乘积的百分数误差值。你可以假定所有的数为正，以简化这一问题。
假设所有的数为正，$c_1, c_2, w_1, w_2, p_1, p_2$ 分别为两个被乘区间的中点、宽度、百分比误差，$l, u, w, c$ 分别为乘积区间的下界、上界、宽度、中点，则
$$ l = (c_1 - w_1)(c_2 - w_2) $$
$$ u = (c_1 + w_1)(c_2 + w_2) $$
$$ w = \frac{u - l}{2} $$
$$ c = \frac{u + l}{2} $$
百分比误差：
$$ \begin{aligned} p &amp;= \frac{w}{c} \\ &amp;= \frac{u - l}{u + l} \\ &amp;= \frac{c_1w_2 + c_2w_1}{c_1c_2 + w_1w_2} \\ &amp;= \frac{p_1 + p_2}{p_1p_2 + 1} \\ &amp;\approx p_1 + p_2 \quad (p_1 \ll 1, p_2 \ll 1) \end{aligned} $$
练习 14 请确认 Lem 是对的。请你用各种不同的算术表达式来检查这一系统的行为。请做出两个区间 $A$ 和 $B$，并用它们计算表达式 $A/A$ 和 $B/B$。如果所用区间的宽度相对于中心值取很小百分数，你将会得到更多的知识。请检查对于中心 &mdash; 百分比形式（见 练习 12 ）进行计算结果。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #lang sicp (define (make-interval a b) (cons a b)) (define (upper-bound i) (max (car i) (cdr i))) (define (lower-bound i) (min (car i) (cdr i))) (define (add-interval x y) (make-interval (+ (lower-bound x) (lower-bound y)) (+ (upper-bound x) (upper-bound y)))) (define (mul-interval x y) (let ((p1 (* (lower-bound x) (lower-bound y))) (p2 (* (lower-bound x) (upper-bound y))) (p3 (* (upper-bound x) (upper-bound y))) (p4 (* (upper-bound x) (lower-bound y)))) (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4)))) (define (div-interval x y) (if (and (&gt; (upper-bound y) 0) (&lt; (lower-bound y) 0)) (error &#34;Not support interval cross 0 -- Div-Interval&#34;) (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))))) (define (center i) (/ (+ (lower-bound i) (upper-bound i)) 2)) (define (width i) (/ (- (upper-bound i) (lower-bound i)) 2)) (define (make-center-percent c p) (let ((w (* c p))) (make-interval (- c w) (+ c w)))) (define (percent i) (/ (width i) (center i))) (define (par1 r1 r2) (div-interval (mul-interval r1 r2) (add-interval r1 r2))) (define (par2 r1 r2) (let ((one (make-interval 1 1))) (div-interval one (add-interval (div-interval one r1) (div-interval one r2))))) ;&gt;&gt;&gt; (define r1 (make-interval 0.9 1.1)) ;&gt;&gt;&gt; (define r2 (make-interval 0.9 1.1)) ;&gt;&gt;&gt; (par1 r1 r2) ;: (0.3681818181818182 . 0.6722222222222224) ;&gt;&gt;&gt; (par2 r1 r2) ;: (0.44999999999999996 . 0.55) ;&gt;&gt;&gt; (define A (make-center-percent 1.0 0.05)) ;&gt;&gt;&gt; (define B (make-center-percent 1.0 0.1)) ;&gt;&gt;&gt; (define q1 (div-interval A A)) ;&gt;&gt;&gt; (define q2 (div-interval A B)) ;&gt;&gt;&gt; (center q1) ;: 1.0050125313283207 ;&gt;&gt;&gt; (percent q1) ;: 0.09975062344139651 ;&gt;&gt;&gt; (center q2) ;: 1.0151515151515151 ;&gt;&gt;&gt; (percent q2) ;: 0.14925373134328368 练习 15 另一用户 Eva Lu Ator 也注意到了由不同的等价代数表达式计算出的区间的差异。她说，如果一个公式可以写成一种形式，其中具有非准确性的变量不重复出现，那么 Alyssa 的系统产生出的区间的限界更紧一些。她说，因此，在计算并联电阻时，par2 是比 par1“更好的”程序。她说得对吗？
对，设 $R_1$ 的区间为 $[a_1, b_1] (a_1 \le b_1)$，$R_2$ 的区间为 $[a_2, b_2] (a_2 \le b_2)$，则 par1 的结果为：
$$ \left[\frac{a_1a_2}{b_1+b_2}, \frac{b_1b_2}{a_1+a_2}\right] $$
par2 的结果为：
$$ \left[\frac{a_1a_2}{a_1+a_2}, \frac{b_1b_2}{b_1+b_2}\right] $$
显然，par2 计算所得的区间宽度不会大于 par1。
练习 16 请给出一个一般性的解释：为什么等价的代数表达式可能导致不同计算结果？你能设计出一个区间算术包，使之没有这种缺陷吗？或者这件事情根本不可能做到？（警告：这个问题非常难。）
在 练习 14 中，$A/A$ 的结果并不是 $1$，原因是对于给定的区间算术运算规则，没有考虑分子和分母的 $A$ 其实是同一个量，始终只能取一样的数值。再比如，将 $\frac{R_1R_2}{R_1 + R_2}$ 中的分母上的 $R_1, R_2$ 分别替换成与 $R_1, R_2$ 相同区间的 $R_3, R_4$，此时
$$ \frac{R_1R_2}{R_1 + R_2} = \frac{R_1R_2}{R_3 + R_4} $$
而 $\frac{R_1R_2}{R_3 + R_4}$ 与 $\frac{1}{1/R_1 + 1/R_2}$ 不存在“等价”关系，便说明了问题。
TODO
练习 17 请定义出过程 last-pair，它返回只包含给定（非空）表里最后一个元素的表：
1 2 (last-pair (list 23 72 149 34)) (34) 1 2 3 4 5 6 7 8 9 #lang sicp (define (last-pair l) (if (null? (cdr l)) l (last-pair (cdr l)))) ;&gt;&gt;&gt; (last-pair (list 23 72 149 34)) ;: (34) 练习 18 请定义出过程 reverse，它以一个表为参数，返回的表中所包含的元素与参数表相同，但排列顺序与参数表相反：
1 2 (reverse (list 1 4 9 16 25)) (25 16 9 4 1) 1 2 3 4 5 6 7 8 9 10 11 #lang sicp (define (reverse l) (define (reverse-iter lst r) (if (null? lst) r (reverse-iter (cdr lst) (cons (car lst) r)))) (reverse-iter l nil)) ;&gt;&gt;&gt; (reverse (list 1 4 9 16 25)) ;: (25 16 9 4 1) 练习 19 请考虑 1.2.2 节的兑换零钱方式计数程序。如果能够轻而易举地改变程序里所用的兑换币种就更好了。譬如说，那样我们就能计算出 1 英镑的不同兑换方式的数目。在写前面那个程序时，有关币种的知识中有一部分出现在过程 first-denomination 里，另一部分出现在过程里 count-change（它知道有 5 种 U.S. 硬币）。如果能够用一个表来提供可用于兑换的硬币就更好了。
我们希望重写出过程 cc，使其第二个参数是一个可用硬币的币值表，而不是一个指定可用硬币种类的整数。而后我们就可以针对各种货币定义出一些表：
1 2 3 (define us-coins (list 50 25 10 5 1)) (define uk-coins (list 100 50 20 10 5 2 1 0.5)) 然后我们就可以通过如下方式调用 cc：
1 2 (cc 100 us-coins) 292 为了做到这件事，我们需要对程序 cc 做一些修改。它仍然具有同样的形式，但将以不同的方式访问自己的第二个参数，如下面所示：
1 2 3 4 5 6 7 8 9 (define (cc amount coin-values) (cond ((= amount 0) 1) ((or (&lt; amount 0) (no-more? coin-values)) 0) (else (+ (cc amount (except-first-denomination coin-values)) (cc (- amount (first-denomination coin-values)) coin-values))))) 请基于表结构上的基本操作，定义出过程 first-denomination、except-first-denomination 和 no-more?。表 coin-values 的排列顺序会影响 cc 给出的回答吗？为什么？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #lang sicp (define us-coins (list 50 25 10 5 1)) (define uk-coins (list 100 50 20 10 5 2 1 0.5)) (define (cc amount coin-values) (cond ((= amount 0) 1) ((or (&lt; amount 0) (no-more? coin-values)) 0) (else (+ (cc amount (except-first-denomination coin-values)) (cc (- amount (first-denomination coin-values)) coin-values))))) (define (except-first-denomination coin-values) (cdr coin-values)) (define (first-denomination coin-values) (car coin-values)) (define (no-more? coin-values) (null? coin-values)) ;&gt;&gt;&gt; (cc 100 us-coins) ;: 292 ;&gt;&gt;&gt; (cc 100 uk-coins) ;: 104561 表 coin-values 的排列顺序不会影响 cc 给出的回答，因为 cc 会遍历给定 coin-values 中所有的可能兑换零钱方式。
练习 20 过程 +、* 和 list 可以取任意个数的实际参数。定义这类过程的一种方式是采用一种带点尾部记法形式的 define。在一个过程定义中，如果在形式参数表的最后一个参数之前有一个点号，那就表明，当这一过程被实际调用时，前面各个形式参数（如果有的话）将以前面的各个实际参数为值，与平常一样。但最后一个形式参数将以所有剩下的实际参数的表为值。例如，假若我们定义了：
1 (define (f x y . z) &lt;body&gt;) 过程 f 就可以用两个以上的参数调用。如果求值：
1 (f 1 2 3 4 5 6) 那么在 f 的体里， x 将是 $1$，y 将是 $2$，而 z 将是表 (3 4 5 6)。给了定义：
1 (define (g . w) &lt;body&gt;) 过程 g 可以用 0 个或多个参数调用。如果求值：
1 (g 1 2 3 4 5 6) 那么在 g 的体里，w 将是表 (1 2 3 4 5 6)。
请采用这种记法形式写出过程 same-parity，它以一个或者多个整数为参数，返回所有与其第一个参数有着同样奇偶性的参数形成的表。例如：
1 2 3 4 5 (same-parity 1 2 3 4 5 6 7) (1 3 5 7) (same-parity 2 3 4 5 6 7) (2 4 6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #lang sicp (define (reverse l) (define (reverse-iter lst r) (if (null? lst) r (reverse-iter (cdr lst) (cons (car lst) r)))) (reverse-iter l nil)) (define (same-parity k . n) (define (iter n r) (if (null? n) r (iter (cdr n) (if (or (and (even? k) (even? (car n))) (and (odd? k) (odd? (car n)))) (cons (car n) r) r)))) (reverse (iter n (list k)))) ;&gt;&gt;&gt; (same-parity 1 2 3 4 5 6 7) ;: (1 3 5 7) ;&gt;&gt;&gt; (same-parity 2 3 4 5 6 7) ;: (2 4 6) 练习 21 过程 square-list 以一个数值表为参数，返回每个数的平方构成的表：
1 2 (square-list (list 1 2 3 4)) (1 4 9 16) 下面是 square-list 的两个定义，请填充其中缺少的表达式以完成它们：
1 2 3 4 5 6 7 (define (square-list items) (if (null? items) nil (cons &lt;??&gt; &lt;??&gt;))) (define (square-list items) (map &lt;??&gt; &lt;??&gt;)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #lang sicp (define (square x) (* x x)) (define (square-list items) (if (null? items) nil (cons (square (car items)) (square-list (cdr items))))) (define (square-list-2 items) (map square items)) ;&gt;&gt;&gt; (square-list (list 1 2 3 4)) ;: (1 4 9 16) ;&gt;&gt;&gt; (square-list-2 (list 1 2 3 4)) ;: (1 4 9 16) 练习 22 Louis Reasoner 试图重写 练习 21 的第一个 square-list 过程，希望使它能生成一个迭代计算过程：
1 2 3 4 5 6 7 8 (define (square-list items) (define (iter things answer) (if (null? things) answer (iter (cdr things) (cons (square (car things)) answer)))) (iter items nil)) 但是很不幸，在按这种方式定义出的 square-list 产生出的结果表中，元素的顺序正好与我们所需要的相反。为什么？
Louis 又试着修正其程序，交换了 cons 的参数：
1 2 3 4 5 6 7 8 (define (square-list items) (define (iter things answer) (if (null? things) answer (iter (cdr things) (cons answer (square (car things)))))) (iter items nil)) 但还是不行。请解释为什么。
前者是因为在用 cons 构造 list 的时候，是从最后一个元素开始往前面构造，因此顺序刚好相反。
后者不符合 cons 构造 list 的规则，cons 构造 list 的话，第一个参数为一个元素，第二个为一个 list（或者 nil）。
练习 23 过程 for-each 与 map 类似，它以一个过程和一个元素表为参数，但它并不返回结果测表，只是将这一过程从左到右应用于各个元素，将过程应用于元素得到的值都丢掉不用。for-each 通常用于那些执行了某些动作的过程，如打印等。看下面例子：
1 2 3 4 5 (for-each (lambda (x) (newline) (display x)) (list 57 321 88)) 57 321 88 由 for-each 的调用返回的值（上面没有显示）可以是某种任意的东西，例如逻辑值真。请给出一个 for-each 的实现。
1 2 3 4 5 6 7 8 9 10 11 12 13 #lang sicp (define (for-each proc items) (cond ((not (null? items)) (proc (car items)) (for-each proc (cdr items))))) ;&gt;&gt;&gt; (for-each (lambda (x) (newline) (display x)) ;&gt;&gt;&gt; (list 57 321 88)) ;: ;: 57 ;: 321 ;: 88 练习 24 假定现在要求值表达式 (list 1 (list 2 (list 3 4)))，请给出由解释器打印出的结果，给出与之对应的盒子指针结构，并将它解释为一棵树（参见图 2-6）。
1 (1 (2 (3 4))) 练习 25 给出能够从下面各表中取出 7 的 car 和 cdr 组合：
1 2 3 4 5 (1 3 (5 7) 9) ((7)) (1 (2 (3 (4 (5 (6 7)))))) 1 2 3 4 5 6 7 #lang sicp (car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9)))))) (car (car (list (list 7)))) (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))))))))))))) 练习 26 假定已将 x 和 y 定义为如下的两个表：
1 2 3 (define x (list 1 2 3)) (define y (list 4 5 6)) 解释器对于下面各个表达式将打印出什么结果：
1 2 3 4 5 (append x y) (cons x y) (list x y) 1 2 3 4 5 (1 2 3 4 5 6) ((1 2 3) 4 5 6) ((1 2 3) (4 5 6)) 练习 27 请修改 练习 18 中所做的 reverse 过程，得到一个 deep-reverse 过程。它以一个表为参数，返回另一个表作为值，结果表中的元素反过来，其中的子树也反转。例如：
1 2 3 4 5 6 7 8 9 10 (define x (list 1 2) (list 3 4)) x ((1 2) (3 4)) (reverse x) ((3 4) (1 2)) (deep-reverse x) ((4 3) (2 1)) 1 2 3 4 5 6 7 8 9 10 11 12 #lang sicp (define (deep-reverse l) (define (iter lst r) (cond ((null? lst) r) ((pair? (car lst)) (iter (cdr lst) (cons (iter (car lst) nil) r))) (else (iter (cdr lst) (cons (car lst) r))))) (iter l nil)) (define x (list (list 1 2) (list 3 4))) (deep-reverse x) 练习 28 写一个过程 fringe，它以一个树（表示为表）为参数，返回一个表，表中的元素是这棵树的所有树叶，按照从左到右的顺序。例如：
1 2 3 4 5 6 7 (define x (list (list 1 2) (list 3 4))) (fringe x) (1 2 3 4) (fringe (list x x)) (1 2 3 4 1 2 3 4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #lang sicp (define (fringe l) (define (iter lst r) (cond ((null? lst) r) ((pair? (car lst)) (append (iter (car lst) nil) (iter (cdr lst) r))) (else (iter (cdr lst) (append r (list (car lst))))))) (iter l nil)) ;&gt;&gt;&gt; (define x (list (list 1 2) (list 3 4))) ;&gt;&gt;&gt; (fringe x) ;: (1 2 3 4) ;&gt;&gt;&gt; (fringe (list x x)) ;: (1 2 3 4 1 2 3 4) 练习 29 一个二叉活动体由两个分支组成，一个是左分支，另一个是右分支，每个分支是一个具有确定长度的杆，上面或者吊着一个重量，或者吊着另一个二叉活动体。我们可以用复合数据对象表示这种二叉活动体，将它通过其两个分支构造起来（例如，使用 list）：
1 2 (define (make-mobile left right) (list left right)) 分支可以从一个 length（它应该是一个数）再加上一个 structure 构造出来，这个 structure 或者是一个数（表示一个简单重量），或者是另一个活动体：
1 2 (define (make-branch length structure) (list length structure)) a) 请写出相应的选择函数 left-branch 和 right-branch，它们分别返回活动体的两个分支。还有 branch-length 和 branch-structure，它们返回一个分支上的成分。
b) 用你的选择函数定义过程 total-weight，它返回一个活动体的总重量。
c) 一个活动体称为是平衡的，如果其左分支的力矩等于其右分支的力矩（也就是说，如果其左杆的长度乘以吊在杆上的重量，等于这个活动体右边的同样乘积），而且在其每个分支上吊着的子活动体也都平衡。请设计一个过程，它能检查一个活动体是否平衡。
d) 假定我们改变活动体的表示，采用下面构造方式：
1 2 3 4 5 (define (make-mobile left right) (cons left right)) (define (make-branch length structure) (cons length structure)) 你需要对自己的程序做多少修改，才能将它改为使用这种新表示？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #lang sicp (define (make-mobile left right) (list left right)) (define (make-branch length structure) (list length structure)) (define (left-branch m) (car m)) (define (right-branch m) (car (cdr m))) (define (branch-length b) (car b)) (define (branch-structure b) (car (cdr b))) (define (total-weight m) (if (pair? m) (+ (total-weight (branch-structure (left-branch m))) (total-weight (branch-structure (right-branch m)))) m)) (define (mobile-balance? m) (if (not (pair? m)) #t (let ((lb (left-branch m)) (rb (right-branch m))) (and (mobile-balance? (branch-structure lb)) (mobile-balance? (branch-structure rb)) (= (* (branch-length lb) (total-weight (branch-structure lb))) (* (branch-length rb) (total-weight (branch-structure rb)))))))) ;&gt;&gt;&gt; (define m (make-mobile ;&gt;&gt;&gt; (make-branch 30 10) ;&gt;&gt;&gt; (make-branch 10 (make-mobile (make-branch 10 20) ;&gt;&gt;&gt; (make-branch 20 10))))) ;&gt;&gt;&gt; (total-weight m) ;: 40 ;&gt;&gt;&gt; (mobile-balance? m) ;: #t ;&gt;&gt;&gt; (define m2 (make-mobile ;&gt;&gt;&gt; (make-branch 20 (make-mobile (make-branch 20 10) ;&gt;&gt;&gt; (make-branch 10 30))) ;&gt;&gt;&gt; (make-branch 10 (make-mobile (make-branch 10 20) ;&gt;&gt;&gt; (make-branch 20 10))))) ;&gt;&gt;&gt; (total-weight m2) ;: 70 ;&gt;&gt;&gt; (mobile-balance? m2) ;: #f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #lang sicp (define (make-mobile left right) (cons left right)) (define (make-branch length structure) (cons length structure)) (define (left-branch m) (car m)) (define (right-branch m) (cdr m)) (define (branch-length b) (car b)) (define (branch-structure b) (cdr b)) 练习 30 请定义一个与 练习 21 中 square-list 过程类似的 square-tree 过程。也就是说，它应该具有下面的行为：
1 2 3 4 5 (square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))) (1 (4 (9 16) 25) (36 49)) 请以两种方式定义 square-tree，直接定义（即不使用任何高阶函数），以及使用 map 和递归定义。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #lang sicp (define (square-tree tree) (cond ((null? tree) nil) ((not (pair? tree)) (* tree tree)) (else (cons (square-tree (car tree)) (square-tree (cdr tree)))))) (define (square-tree2 tree) (map (lambda (sub-tree) (if (not (pair? sub-tree)) (* sub-tree sub-tree) (square-tree2 sub-tree))) tree)) ;&gt;&gt;&gt; (square-tree ;&gt;&gt;&gt; (list 1 ;&gt;&gt;&gt; (list 2 (list 3 4) 5) ;&gt;&gt;&gt; (list 6 7))) ;: (1 (4 (9 16) 25) (36 49)) ;&gt;&gt;&gt; (square-tree2 ;&gt;&gt;&gt; (list 1 ;&gt;&gt;&gt; (list 2 (list 3 4) 5) ;&gt;&gt;&gt; (list 6 7))) ;: (1 (4 (9 16) 25) (36 49)) 练习 31 将你在 练习 30 做出的解答进一步抽象，做出一个过程，使它的性质保证能以下面形式定义 square-tree：
1 (define (square-tree tree) (tree-map square tree)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #lang sicp (define (tree-map proc tree) (map (lambda (sub-tree) (if (not (pair? sub-tree)) (proc sub-tree) (tree-map proc sub-tree))) tree)) (define (square x) (* x x)) (define (square-tree tree) (tree-map square tree)) ;&gt;&gt;&gt; (square-tree ;&gt;&gt;&gt; (list 1 ;&gt;&gt;&gt; (list 2 (list 3 4) 5) ;&gt;&gt;&gt; (list 6 7))) ;: (1 (4 (9 16) 25) (36 49)) 练习 32 我们可以将一个集合表示为一个元素互不相同的表，因此就可以将一个集合的所有子集表示为表的表。例如，假定集合为 (1 2 3)，它的所有子集的集合就是 (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))。请完成下面的过程定义，它生成出一个集合的所有子集的集合。请解释它为什么能完成这一工作。
1 2 3 4 5 (define (subsets s) (if (null? s) (list nil) (let ((rest (subsets (cdr s)))) (append rest (map &lt;??&gt; rest))))) 1 2 3 4 5 6 7 8 9 10 11 12 #lang sicp (define (subsets s) (if (null? s) (list nil) (let ((rest (subsets (cdr s)))) (append rest (map (lambda (e) (cons (car s) e)) rest))))) ;&gt;&gt;&gt; (subsets (list 1 2 3)) ;: (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)) 首先，rest 表示集合 s 不含 (car s) 的所有子集，而含 (car s) 的子集刚好是 rest 中每个集合添加元素 (car s)，将二者拼接，便得到 s 的所有子集。
练习 33 请填充下面缺失的表达式，完成将一些基本的表操作看作累积的定义：
1 2 3 4 5 6 7 8 (define (map p sequence) (accumulate (lambda (x y) &lt;??&gt;) nil sequence)) (define (append seq1 seq2) (accumulate cons &lt;??&gt; &lt;??&gt;)) (define (length sequence) (accumulate &lt;??&gt; 0 sequence)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #lang sicp (define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) (define (map p sequence) (accumulate (lambda (x y) (cons (p x) y)) nil sequence)) (define (append seq1 seq2) (accumulate cons seq2 seq1)) (define (length sequence) (accumulate (lambda (x y) (+ 1 y)) 0 sequence)) ;&gt;&gt;&gt; (map (lambda (x) (+ 1 x)) (list 1 2 3)) ;: (2 3 4) ;&gt;&gt;&gt; (append (list 1 2 3) (list 4 5 6)) ;: (1 2 3 4 5 6) ;&gt;&gt;&gt; (length (list 1 2 3)) ;: 3 练习 34 对于 $x$ 的某个给定值，求出一个多项式在 $x$ 的值，也可以形式化为一种累积。假定需要求下面多项式的值：
$$ a_nx^n + a_{n-1}x^{n-1} + \cdots + a_1x + a_0 $$
采用著名的 Horner 规则，可以构造出下面的计算：
$$ (\cdots (a_nx + a_{n-1})x + \cdots + a_1)x + a_0 $$
换句话说，我们可以从 $a_n$ 开始，乘以 $x$，再加上 $a_{n-1}$，乘以 $x$，如此下去，知道处理完 $a_0$。请填充下面的模板，做出一个利用 Horner 规则求多项式值的过程。假定多项式的系数安排在一个序列里，从 $a_0$ 直至 $a_n$。
1 2 3 4 (define (horner-eval x coefficient-sequence) (accumulate (lambda (this-coeff higher-terms) &lt;??&gt;) 0 coefficient-sequence)) 例如，为了计算 $1 + 3x + 5x^3 + x^5$ 在 $x = 2$ 的值，你需要求值：
1 (horner-eval 2 (list 1 3 0 5 0 1)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #lang sicp (define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) (define (horner-eval x coefficient-sequence) (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms))) 0 coefficient-sequence)) ;&gt;&gt;&gt; (horner-eval 2 (list 1 3 0 5 0 1)) ;: 79 练习 35 将 2.2.2 节的 count-leaves 重新定义为一个累积：
1 2 (define (count-leaves t) (accumulate &lt;??&gt; &lt;??&gt; (map &lt;??&gt; &lt;??&gt;))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #lang sicp (define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) (define (count-leaves t) (accumulate (lambda (x y) (+ x y)) 0 (map (lambda (s) (if (pair? s) (count-leaves s) 1)) t))) (count-leaves (list 1 (list 2 (list 3 4)))) 练习 36 过程 accumulate-n 与 accumulate 类似，除了它的第三个参数是一个序列的序列，假定其中每个序列的元素个数相同。它用指定的累积过程去组合起所有序列的第一个元素，而后是所有序列的第二个元素，并如此做下去，返回得到的所有结果的序列。例如，如果 s 是包含着 4 个序列的序列 ((1 2 3) (4 5 6) (7 8 9) (10 11 12))，那么 (accumulate-n + 0 s) 的值就应该是序列 (22 26 30)。请填充下面 accumulate-n 定义中所缺失的表达式：
1 2 3 4 5 (define (accumulate-n op init seqs) (if (null? (car seqs)) nil (cons (accumulate op init &lt;??&gt;) (accumulate-n op init &lt;??&gt;)))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #lang sicp (define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) (define (accumulate-n op init seqs) (if (null? (car seqs)) nil (cons (accumulate op init (map (lambda (s) (car s)) seqs)) (accumulate-n op init (map (lambda (s) (cdr s)) seqs))))) ;&gt;&gt;&gt; (define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12))) ;&gt;&gt;&gt; (accumulate-n + 0 s) ;: (22 26 30) 练习 37 假定我们将向量 $v = (v_i)$ 表示为数的序列，将矩阵 $m = (m_{ij})$ 表示为向量（矩阵行）的序列。例如，矩阵：
$$ \begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \\ 4 &amp; 5 &amp; 6 &amp; 6 \\ 6 &amp; 7 &amp; 8 &amp; 9 \end{bmatrix} $$
用序列 ((1 2 3 4) (4 5 6 6) (6 7 8 9)) 表示。对于这种表示，我们可以用序列操作简洁地表达基本的矩阵与向量运算。这些运算（任何有关矩阵代数的书里都有描述）如下：
(dot-product v w) | 返回和 $\sum_i v_i w_i$;
(matrix-*-vector m v) | 返回向量 $t$，其中 $t_i = \sum_j m_{ij} v_j$;
(matrix-*-matrix m n) | 返回矩阵 $p$，其中 $p_{ij} = \sum_k m_{ik} n_{kj}$;
(transpose m) | 返回矩阵 $n$，其中 $n_{ij} = m_{ji}$;
我们可以将点积（dot product）定义为：
1 2 (define (dot-product v w) (accumulate + 0 (map * v w))) 请填充下面过程里缺失的表达式，它们计算出其他的矩阵运算结果（过程 accumulate-n 在 练习 36 中定义）。
1 2 3 4 5 6 7 8 9 (define (matrix-*-vector m v) (map &lt;??&gt; m)) (define (transpose mat) (accumulate-n &lt;??&gt; &lt;??&gt; mat)) (define (matrix-*-matrix m n) (let ((cols (transpose n))) (map &lt;??&gt; m))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #lang sicp (define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) (define (accumulate-n op init seqs) (if (null? (car seqs)) nil (cons (accumulate op init (map (lambda (s) (car s)) seqs)) (accumulate-n op init (map (lambda (s) (cdr s)) seqs))))) (define (dot-product v w) (accumulate + 0 (map * v w))) (define (matrix-*-vector m v) (map (lambda (row) (dot-product row v)) m)) (define (transpose mat) (accumulate-n cons nil mat)) (define (matrix-*-matrix m n) (let ((cols (transpose n))) (map (lambda (row) (matrix-*-vector cols row)) m))) ;&gt;&gt;&gt; (define v (list 1 2 3 4)) ;&gt;&gt;&gt; (define w (list 5 6 7 8)) ;&gt;&gt;&gt; (define m (list (list 1 2 3 4) (list 4 5 6 6) (list 6 7 8 9))) ;&gt;&gt;&gt; (dot-product v w) ;: 70 ;&gt;&gt;&gt; (matrix-*-vector m v) ;: (30 56 80) ;&gt;&gt;&gt; (matrix-*-matrix m (transpose m)) ;: ((30 56 80) (56 113 161) (80 161 230)) ;&gt;&gt;&gt; (matrix-*-matrix (transpose m) m) ;: ((53 64 75 82) (64 78 92 101) (75 92 109 120) (82 101 120 133)) 练习 38 过程 accumulate 也称为 fold-right，因为它将序列的第一个元素组合到右边所有元素的组合结果上。也有一个 fold-left，它与 fold-right 类似，但却是按照相反方向去操作各个元素：
1 2 3 4 5 6 7 (define (fold-left op initial sequence) (define (iter result rest) (if (null? rest) result (iter (op result (car rest)) (cdr rest)))) (iter initial sequence)) 下面表达式的值是什么？
1 2 3 4 5 6 7 (fold-right / 1 (list 1 2 3)) (fold-left / 1 (list 1 2 3)) (fold-right list nil (list 1 2 3)) (fold-left list nil (list 1 2 3)) 如果要求用某个 op 时保证 fold-right 和 fold-left 对任何序列都产生同样的结果，请给出 op 应该满足的性质。
1 2 3 4 5 6 7 3/2 1/6 (3 (2 (1 ()))) (((() 1) 2) 3) 要求用某个 op 时保证 fold-right 和 fold-left 对任何序列都产生同样的结果的话，op 应满足交换律，即 (op a b) = (op b a)。
练习 39 基于 练习 38 的 fold-right 和 fold-left 完成 reverse （ 练习 18 ）下面的定义：
1 2 3 4 5 (define (reverse sequence) (fold-right (lambda (x y) &lt;??&gt;) nil sequence)) (define (reverse sequence) (fold-left (lambda (x y) &lt;??&gt;) nil sequence)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #lang sicp (define (fold-left op initial sequence) (define (iter result rest) (if (null? rest) result (iter (op result (car rest)) (cdr rest)))) (iter initial sequence)) (define (fold-right op initial sequence) (define (iter result rest) (if (null? rest) result (iter (op (car rest) result) (cdr rest)))) (iter initial sequence)) (define (reverse sequence) (fold-right (lambda (x y) (cons x y)) nil sequence)) (define (reverse2 sequence) (fold-left (lambda (x y) (cons y x)) nil sequence)) ;&gt;&gt;&gt; (reverse (list 1 2 3 4)) ;: (4 3 2 1) ;&gt;&gt;&gt; (reverse2 (list 1 2 3 4)) ;: (4 3 2 1) 练习 40 请定义过程 unique-pairs，给它整数 $n$，它产生出序列 $(i, j)$，其中 $1 \le j \lt i \le n$。请用 unique-pairs 去简化上面 prime-sum-pairs 的定义。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #lang sicp (define (filter predicate sequence) (cond ((null? sequence) nil) ((predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence)))) (else (filter predicate (cdr sequence))))) (define (enumerate-interval m n) (if (&gt; m n) nil (cons m (enumerate-interval (+ 1 m) n)))) (define (unique-pairs n) (if (&lt;= n 1) nil (append (map (lambda (j) (list n j)) (enumerate-interval 1 (- n 1))) (unique-pairs (- n 1))))) (define (prime? n) (define (smallest-divisor n) (find-divisor n 2)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (define (square x) (* x x)) (define (divides? a b) (= (remainder b a) 0)) (= (smallest-divisor n) n)) (define (prime-sum-pairs n) (filter (lambda (p) (prime? (+ (car p) (cadr p)))) (unique-pairs n))) ;&gt;&gt;&gt; (prime-sum-pairs 6) ;: ((6 1) (6 5) (5 2) (4 1) (4 3) (3 2) (2 1)) 练习 41 请写出一个过程，它能产生出所有小于等于给定整数 $n$ 的正的相异整数 $i$、$j$ 和 $k$ 的有序三元组，使每个三元组的三个元素之和等于给定的整数 $s$。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #lang sicp (define (filter predicate sequence) (cond ((null? sequence) nil) ((predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence)))) (else (filter predicate (cdr sequence))))) (define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) (define (flatmap proc seq) (accumulate append nil (map proc seq))) (define (enumerate-interval m n) (if (&gt; m n) nil (cons m (enumerate-interval (+ 1 m) n)))) (define (unique-triples n) (if (&lt;= n 2) nil (append (flatmap (lambda (j) (map (lambda (k) (list n j k)) (enumerate-interval 1 (- j 1)))) (enumerate-interval 2 (- n 1))) (unique-triples (- n 1))))) (define (permute-triples seqs) (flatmap (lambda (seq) (let ((a (car seq)) (b (cadr seq)) (c (caddr seq))) (list (list a b c) (list a c b) (list b c a) (list b a c) (list c a b) (list c b a)))) seqs)) (define (triple-sum n s) (permute-triples (filter (lambda (triple) (= s (+ (car triple) (cadr triple) (caddr triple)))) (unique-triples n)))) ;&gt;&gt;&gt; (triple-sum 10 7) ;: ((4 2 1) (4 1 2) (2 1 4) (2 4 1) (1 4 2) (1 2 4)) ;&gt;&gt;&gt; (triple-sum 10 9) ;: ((6 2 1) (6 1 2) (2 1 6) (2 6 1) (1 6 2) (1 2 6) (5 3 1) (5 1 3) (3 1 5) (3 5 1) (1 5 3) (1 3 5) (4 3 2) (4 2 3) (3 2 4) (3 4 2) (2 4 3) (2 3 4)) 练习 42 “八皇后谜题”问的是怎样将八个皇后摆在国际象棋棋盘上，使得任意一个皇后都不能攻击另一个皇后（也就是说，任意两个皇后都不在同一行、同一列或者同一对角线上）。一个可能的解如下图所示。解决这一谜题的一种方法按一个方向处理棋盘，每次在每一列里放一个皇后，如果现在已经放好了 $k-1$ 个皇后，第 $k$ 个皇后就必须放在不会被已在棋盘上的任何皇后攻击的位置上。我们可以递归地描述这一过程：假定我们已经生成了在棋盘的前 $k-1$ 列中放置 $k-1$ 个皇后的所有可能方式，现在需要的就是对于其中的每种方式，生成出将下一个皇后放在第 $k$ 列中每一行的扩充集合。而后过滤它们，只留下能使位于第 $k$ 列的皇后与其他皇后相安无事的那些扩充。这样就能产生出将 $k$ 个皇后放置在前 $k$ 列的所有格局的序列。继续这一过程，我们将能产生出这一谜题的所有解，而不是一个解。
将这一解法实现为一个过程 queens，令它返回在 $n\times n$ 棋盘上放 $n$ 个皇后的所有解的序列。queens 内部的过程 queen-cols，返回在棋盘的前 $k$ 列中放皇后的所有格局的序列。
1 2 3 4 5 6 7 8 9 10 11 12 13 (define (queens board-size) (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (positions) (safe? k positions)) (flatmap (lambda (rest-of-queens) (map (lambda (new-row) (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size))) (queen-cols (- k 1)))))) (queen-cols board-size)) 这个过程里的 rest-of-queens 是在前 $k-1$ 列放置 $k-1$ 个皇后的一种方式，new-row 是在第 $k$ 列放置所考虑的行编号。请完成这一程序，为此需要实现一种棋盘格局集合的表示方法；还要实现过程 adjoin-position，它将一个新的行列格局加入一个格局集合中，在第 $k$ 列的皇后相对于其他列的皇后是否为安全的（请注意，我们只需检查新皇后是否安全 &mdash; 其他皇后已经保证相安无事了）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 #lang sicp (define (reverse sequence) (if (null? sequence) nil (append (reverse (cdr sequence)) (list (car sequence))))) (define (filter predicate sequence) (cond ((null? sequence) nil) ((predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence)))) (else (filter predicate (cdr sequence))))) (define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) (define (flatmap proc seq) (accumulate append nil (map proc seq))) (define (enumerate-interval m n) (if (&gt; m n) nil (cons m (enumerate-interval (+ 1 m) n)))) (define empty-board nil) (define (adjoin-position new-row k rest-of-queens) (cons new-row rest-of-queens)) (define (safe? k positions) (let ((row (car positions)) (sum-row-col (+ (car positions) k)) (diff-row-col (- (car positions) k))) (accumulate (lambda (a b) (and a b)) #t (map (lambda (pos col) (and (not (= row pos)) (not (= sum-row-col (+ pos col))) (not (= diff-row-col (- pos col))))) (cdr positions) (reverse (enumerate-interval 1 (- k 1))))))) (define (queens board-size) (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (positions) (safe? k positions)) (flatmap (lambda (rest-of-queens) (map (lambda (new-row) (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size))) (queen-cols (- k 1)))))) (queen-cols board-size)) ;&gt;&gt;&gt; (queens 8) ;: ((4 2 7 3 6 8 5 1) ;: (5 2 4 7 3 8 6 1) ;: (3 5 2 8 6 4 7 1) ;: (3 6 4 2 8 5 7 1) ;: (5 7 1 3 8 6 4 2) ;: (4 6 8 3 1 7 5 2) ;: (3 6 8 1 4 7 5 2) ;: (5 3 8 4 7 1 6 2) ;: (5 7 4 1 3 8 6 2) ;: (4 1 5 8 6 3 7 2) ;: (3 6 4 1 8 5 7 2) ;: (4 7 5 3 1 6 8 2) ;: (6 4 2 8 5 7 1 3) ;: (6 4 7 1 8 2 5 3) ;: (1 7 4 6 8 2 5 3) ;: (6 8 2 4 1 7 5 3) ;: (6 2 7 1 4 8 5 3) ;: (4 7 1 8 5 2 6 3) ;: (5 8 4 1 7 2 6 3) ;: (4 8 1 5 7 2 6 3) ;: (2 7 5 8 1 4 6 3) ;: (1 7 5 8 2 4 6 3) ;: (2 5 7 4 1 8 6 3) ;: (4 2 7 5 1 8 6 3) ;: (5 7 1 4 2 8 6 3) ;: (6 4 1 5 8 2 7 3) ;: (5 1 4 6 8 2 7 3) ;: (5 2 6 1 7 4 8 3) ;: (6 3 7 2 8 5 1 4) ;: (2 7 3 6 8 5 1 4) ;: (7 3 1 6 8 5 2 4) ;: (5 1 8 6 3 7 2 4) ;: (1 5 8 6 3 7 2 4) ;: (3 6 8 1 5 7 2 4) ;: (6 3 1 7 5 8 2 4) ;: (7 5 3 1 6 8 2 4) ;: (7 3 8 2 5 1 6 4) ;: (5 3 1 7 2 8 6 4) ;: (2 5 7 1 3 8 6 4) ;: (3 6 2 5 8 1 7 4) ;: (6 1 5 2 8 3 7 4) ;: (8 3 1 6 2 5 7 4) ;: (2 8 6 1 3 5 7 4) ;: (5 7 2 6 3 1 8 4) ;: (3 6 2 7 5 1 8 4) ;: (6 2 7 1 3 5 8 4) ;: (3 7 2 8 6 4 1 5) ;: (6 3 7 2 4 8 1 5) ;: (4 2 7 3 6 8 1 5) ;: (7 1 3 8 6 4 2 5) ;: (1 6 8 3 7 4 2 5) ;: (3 8 4 7 1 6 2 5) ;: (6 3 7 4 1 8 2 5) ;: (7 4 2 8 6 1 3 5) ;: (4 6 8 2 7 1 3 5) ;: (2 6 1 7 4 8 3 5) ;: (2 4 6 8 3 1 7 5) ;: (3 6 8 2 4 1 7 5) ;: (6 3 1 8 4 2 7 5) ;: (8 4 1 3 6 2 7 5) ;: (4 8 1 3 6 2 7 5) ;: (2 6 8 3 1 4 7 5) ;: (7 2 6 3 1 4 8 5) ;: (3 6 2 7 1 4 8 5) ;: (4 7 3 8 2 5 1 6) ;: (4 8 5 3 1 7 2 6) ;: (3 5 8 4 1 7 2 6) ;: (4 2 8 5 7 1 3 6) ;: (5 7 2 4 8 1 3 6) ;: (7 4 2 5 8 1 3 6) ;: (8 2 4 1 7 5 3 6) ;: (7 2 4 1 8 5 3 6) ;: (5 1 8 4 2 7 3 6) ;: (4 1 5 8 2 7 3 6) ;: (5 2 8 1 4 7 3 6) ;: (3 7 2 8 5 1 4 6) ;: (3 1 7 5 8 2 4 6) ;: (8 2 5 3 1 7 4 6) ;: (3 5 2 8 1 7 4 6) ;: (3 5 7 1 4 2 8 6) ;: (5 2 4 6 8 3 1 7) ;: (6 3 5 8 1 4 2 7) ;: (5 8 4 1 3 6 2 7) ;: (4 2 5 8 6 1 3 7) ;: (4 6 1 5 2 8 3 7) ;: (6 3 1 8 5 2 4 7) ;: (5 3 1 6 8 2 4 7) ;: (4 2 8 6 1 3 5 7) ;: (6 3 5 7 1 4 2 8) ;: (6 4 7 1 3 5 2 8) ;: (4 7 5 2 6 1 3 8) ;: (5 7 2 6 3 1 4 8)) 练习 43 Louis Reasoner 在做 练习 42 时遇到了麻烦，他的 queens 过程看起来能行，但却运行得极慢（Louis 居然无法忍耐到它解 $6\times 6$ 棋盘的问题）。当 Louis 请 Eva Lu Ator 帮忙时，她指出他在 flatmap 里交换了嵌套映射的顺序，将它写成了：
1 2 3 4 5 6 (flatmap (lambda (new-row) (map (lambda (rest-of-queens) (adjoin-position new-row k rest-of-queens)) (queen-cols (- k 1)))) (enumerate-interval 1 board-size)) 请解释一下，为什么这样交换顺序会使程序运行得非常慢。估计一下，用 Louis 的程序去解决八皇后问题大约需要多少时间，假定 练习 42 中的程序需要时间 $T$ 求解这一难题。
嵌套顺序调换后，flatmap 在映射 (enumerate-interval 1 board-size) 的每一个元素时，都要重复计算 (queen-cols (- k 1))，由于 board-size 为 8，所需时间大约为 $8T$。
练习 44 请定义出 corner-split 里使用的过程 up-split，它与 right-split 类似，除在其中交换了 below 和 beside 的角色之外。
1 2 3 4 5 6 7 #lang sicp (define (up-split painter n) (if (= n 0) painter (let ((smaller (up-split painter (- n 1)))) (below painter (beside smaller smaller))))) 练习 45 可以将 right-split 和 up-split 表述为某种广义划分操作的实例。请定义一个过程 split，使它具有如下性质，求值：
1 2 3 (define right-split (split beside below)) (define up-split (split below beside)) 产生过程 right-split 和 up-split，其行为与前面定义的过程一样。
1 2 3 4 5 6 7 8 9 #lang sicp (define (split orient1 orient2) (define (iter painter n) (if (= n 0) painter (let ((smaller (iter painter (- n 1)))) (orient1 painter (orient2 smaller smaller))))) iter) 练习 46 从原点出发的一个两维向量 $\bm{v}$ 可以用一个由 $x$ 坐标和 $y$ 坐标构成的序列表示。请为这样的向量实现一个数据抽象：给出一个构造函数 make-vect，以及对应的选择函数 xcor-vect 和 ycor-vect。借助于你给出的构造函数和选择函数，实现过程 add-vect、sub-vect 和 scale-vect，它们能完成向量加法、向量减法和向量的伸缩。
$$ (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2) $$ $$ (x_1, y_1) - (x_2, y_2) = (x_1 - x_2, y_1 - y_2) $$ $$ s \cdot (x, y) = (sx, sy) $$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #lang sicp (define (make-vect x y) (cons x y)) (define (xcor-vect v) (car v)) (define (ycor-vect v) (cdr v)) (define (add-vect v1 v2) (make-vect (+ (xcor-vect v1) (xcor-vect v2)) (+ (ycor-vect v1) (ycor-vect v2)))) (define (sub-vect v1 v2) (make-vect (- (xcor-vect v1) (xcor-vect v2)) (- (ycor-vect v1) (ycor-vect v2)))) (define (scale-vect s v) (make-vect (* s (xcor-vect v)) (* s (ycor-vect v)))) 练习 47 下面是实现框架的两个可能的过程函数：
1 2 3 4 5 (define (make-frame origin edge1 edge2) (list origin edge1 edge2)) (define (make-frame origin edge1 edge2) (cons (origin) (cons edge1 edge2))) 请为每个构造函数提供适当的选择函数，为框架做出相应的实现。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #lang sicp (define (make-frame origin edge1 edge2) (list origin edge1 edge2)) (define (origin-frame frame) (car frame)) (define (edge1-frame frame) (cadr frame)) (define (edge2-frame frame) (caddr frame)) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; ; (define (make-frame origin edge1 edge2) ; (cons origin (cons edge1 edge2))) ; ; (define (origin-frame frame) ; (car frame)) ; ; (define (edge1-frame frame) ; (cadr frame)) ; ; (define (edge2-frame frame) ; (cddr frame)) ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 练习 48 平面上的一条直线可以用一对向量表示 &mdash; 从原点到线段起点的向量，以及从原点到线段终点的向量。请用你在 练习 46 做出的向量表示定义一种线段表示，其中用构造函数 make-segment 以及选择函数 start-segment 和 end-segment。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #lang sicp (define (make-vect x y) (cons x y)) (define (xcor-vect v) (car v)) (define (ycor-vect v) (cdr v)) (define (make-segment v1 v2) (cons v1 v2)) (define (start-segment s) (car s)) (define (end-segment s) (cdr s)) 练习 49 利用 segments-&gt;painter 定义下面的基本画家：
a) 画出给定框架边界的画家。
b) 通过连接框架两对角画出一个大叉子的画家。
c) 通过连接框架各边的中点画出一个菱形的画家。
d) 画家 wave。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #lang sicp (#%require sicp-pict) (define (edges-&gt;painter frame) ((segments-&gt;painter (list (make-segment (make-vect 0 0) (make-vect 1 0)) (make-segment (make-vect 1 0) (make-vect 1 1)) (make-segment (make-vect 1 1) (make-vect 0 1)) (make-segment (make-vect 0 1) (make-vect 0 0)))) frame)) (define (diags-&gt;painter frame) ((segments-&gt;painter (list (make-segment (make-vect 0 0) (make-vect 1 1)) (make-segment (make-vect 1 0) (make-vect 0 1)))) frame)) (define (midpoints-&gt;painter frame) ((segments-&gt;painter (list (make-segment (make-vect 0.5 0) (make-vect 1 0.5)) (make-segment (make-vect 1 0.5) (make-vect 0.5 1)) (make-segment (make-vect 0.5 1) (make-vect 0 0.5)) (make-segment (make-vect 0 0.5) (make-vect 0.5 0)))) frame)) (define (wave-&gt;painter frame) ((segments-&gt;painter (list (make-segment (make-vect 0.20 0.00) (make-vect 0.35 0.50)) (make-segment (make-vect 0.35 0.50) (make-vect 0.30 0.60)) (make-segment (make-vect 0.30 0.60) (make-vect 0.15 0.45)) (make-segment (make-vect 0.15 0.45) (make-vect 0.00 0.60)) (make-segment (make-vect 0.00 0.80) (make-vect 0.15 0.65)) (make-segment (make-vect 0.15 0.65) (make-vect 0.30 0.70)) (make-segment (make-vect 0.30 0.70) (make-vect 0.40 0.70)) (make-segment (make-vect 0.40 0.70) (make-vect 0.35 0.85)) (make-segment (make-vect 0.35 0.85) (make-vect 0.40 1.00)) (make-segment (make-vect 0.60 1.00) (make-vect 0.65 0.85)) (make-segment (make-vect 0.65 0.85) (make-vect 0.60 0.70)) (make-segment (make-vect 0.60 0.70) (make-vect 0.75 0.70)) (make-segment (make-vect 0.75 0.70) (make-vect 1.00 0.40)) (make-segment (make-vect 1.00 0.20) (make-vect 0.60 0.48)) (make-segment (make-vect 0.60 0.48) (make-vect 0.80 0.00)) (make-segment (make-vect 0.40 0.00) (make-vect 0.50 0.30)) (make-segment (make-vect 0.50 0.30) (make-vect 0.60 0.00)))) frame)) 1 (paint edges-&gt;painter #:height 512 #:width 512) 1 (paint diags-&gt;painter #:height 512 #:width 512) 1 (paint midpoints-&gt;painter #:height 512 #:width 512) 1 (paint wave-&gt;painter #:height 512 #:width 512) 练习 50 请定义变换 flip-horiz，它能在水平方向上反转画家。再定义出对画家做反时针方向 180 度和 270 度旋转的变换。
1 2 3 4 5 6 7 8 #lang sicp (#%require sicp-pict) (define (flip-horiz painter) (transform-painter painter (make-vect 1.0 0.0) (make-vect 0.0 0.0) (make-vect 1.0 1.0))) 练习 51 定义对画家的 below 操作，它以两个画家为参数。在给定了一个框架后，由 below 得到的画家将要求第一个画家在框架的下部画图，要求第二个画家在框架的上部画图。请按两种方式定义 below：首先写出一个类似于上面 beside 的过程：另一个则直接通过 beside 和适当的旋转操作（来自 练习 50 ）完成有关工作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #lang sicp (#%require sicp-pict) (define (below painter1 painter2) (let ((split-point (make-vect 0.0 0.5))) (let ((paint-below (transform-painter painter1 (make-vect 0.0 0.0) (make-vect 1.0 0.0) split-point)) (paint-up (transform-painter painter2 split-point (make-vect 1.0 0.5) (make-vect 0.0 1.0)))) (lambda (frame) (paint-below frame) (paint-up frame))))) #;(define (below painter1 painter2) (rotate270 (beside (rotate90 painter2) (rotate90 painter1)))) 练习 52 在上面描述的各个层次上工作，修改图 2-9 中所示的方块的限制。特别是：
a) 给 练习 49 的基本 wave 画家加入某些线段（例如，加上一个笑脸）。
b) 修改 corner-split 的构造模式（例如，只用 up-split 和 right-split 的图像的各一个副本，而不是两个）。
c) 修改 square-limit，换一种使用 square-of-four 的方式，以另一种不同模式组合起各个角区（例如，你可以让大的 Rogers 先生从正方形的每个角向外看）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #lang sicp (#%require sicp-pict) (define (wave-smile-&gt;painter frame) ((segments-&gt;painter (list (make-segment (make-vect 0.20 0.00) (make-vect 0.35 0.50)) (make-segment (make-vect 0.35 0.50) (make-vect 0.30 0.60)) (make-segment (make-vect 0.30 0.60) (make-vect 0.15 0.45)) (make-segment (make-vect 0.15 0.45) (make-vect 0.00 0.60)) (make-segment (make-vect 0.00 0.80) (make-vect 0.15 0.65)) (make-segment (make-vect 0.15 0.65) (make-vect 0.30 0.70)) (make-segment (make-vect 0.30 0.70) (make-vect 0.40 0.70)) (make-segment (make-vect 0.40 0.70) (make-vect 0.35 0.85)) (make-segment (make-vect 0.35 0.85) (make-vect 0.40 1.00)) (make-segment (make-vect 0.60 1.00) (make-vect 0.65 0.85)) (make-segment (make-vect 0.65 0.85) (make-vect 0.60 0.70)) (make-segment (make-vect 0.60 0.70) (make-vect 0.75 0.70)) (make-segment (make-vect 0.75 0.70) (make-vect 1.00 0.40)) (make-segment (make-vect 1.00 0.20) (make-vect 0.60 0.48)) (make-segment (make-vect 0.60 0.48) (make-vect 0.80 0.00)) (make-segment (make-vect 0.40 0.00) (make-vect 0.50 0.30)) (make-segment (make-vect 0.50 0.30) (make-vect 0.60 0.00)) (make-segment (make-vect 0.40 0.90) (make-vect 0.425 0.95)) (make-segment (make-vect 0.425 0.95) (make-vect 0.45 0.90)) (make-segment (make-vect 0.55 0.90) (make-vect 0.575 0.95)) (make-segment (make-vect 0.575 0.95) (make-vect 0.60 0.90)) (make-segment (make-vect 0.47 0.80) (make-vect 0.53 0.80)))) frame)) (define (split orient1 orient2) (define (iter painter n) (if (= n 0) painter (let ((smaller (iter painter (- n 1)))) (orient1 painter (orient2 smaller smaller))))) iter) (define right-split (split beside below)) (define up-split (split below beside)) (define (corner-split painter n) (if (= n 0) painter (let ((up (up-split painter (- n 1))) (right (right-split painter (- n 1)))) (let ((top-left up) (bottom-right right) (corner (corner-split painter (- n 1)))) (beside (below painter top-left) (below bottom-right corner)))))) (define (square-of-four tl tr bl br) (lambda (painter) (let ((top (beside (tl painter) (tr painter))) (bottom (beside (bl painter) (br painter)))) (below bottom top)))) (define (square-limit painter n) (let ((combine4 (square-of-four identity flip-horiz flip-vert rotate180))) (combine4 (corner-split painter n)))) 1 (paint wave-smile-&gt;painter #:height 512 #:width 512) 1 (paint (corner-split wave-smile-&gt;painter 3) #:height 512 #:width 512) 1 (paint (square-limit einstein 3) #:height 512 #:width 512) 练习 53 解释器在求值下面的各个表达式时将打印出什么？
1 2 3 4 5 6 7 8 9 10 11 12 13 (list &#39;a &#39;b &#39;c) (list (list &#39;george)) (cdr &#39;((x1 x2) (y1 y2))) (cadr &#39;((x1 x2) (y1 y2))) (pair? (car &#39;(a short list))) (memq &#39;red &#39;((red shoes) (blue socks))) (memq &#39;red &#39;(red shoes blue socks)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #lang sicp (list &#39;a &#39;b &#39;c) ;: (a b c) (list (list &#39;george)) ;: ((george)) (cdr &#39;((x1 x2) (y1 y2))) ;: ((y1 y2)) (cadr &#39;((x1 x2) (y1 y2))) ;: (y1 y2) (pair? (car &#39;(a short list))) ;: #f (memq &#39;red &#39;((red shoes) (blue socks))) ;: #f (memq &#39;red &#39;(red shoes blue socks)) ;: (red shoes blue socks) 练习 54 如果两个表包含着同样元素，这些元素也按同样顺序排列，那么就称这两个表 equal?。例如：
1 (equal? &#39;(this is a list) &#39;(this is a list)) 是真；而
1 (equal? &#39;(this is a list) &#39;(this (is a) list)) 是假。说得更准确些，我们可以从符号相等的基本 eq? 出发，以递归方式定义出 equal?。a 和 b 是 equal? 的，如果它们都是符号，而且这两个符号满足 eq?；或者它们都是表，而且 (car a) 和 (car b) 相互 equal?，它们的 (cdr a) 和 (cdr b) 也是 equal?。请利用这一思路定义出 equal? 过程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #lang sicp (define (equal? a b) (if (null? a) (if (null? b) #t #f) (if (null? b) #f (if (not (pair? (car a))) (if (not (pair? (car b))) (and (eq? (car a) (car b)) (equal? (cdr a) (cdr b))) #f) (if (not (pair? (car b))) #f (and (equal? (car a) (car b)) (equal? (cdr a) (cdr b)))))))) 练习 55 Eva Lu Ator 输入了表达式：
1 (car &#39;&#39;abracadabra) 令她吃惊的是解释器打印出的是 quote。请解释这一情况。
由于 ' 实际是 quote 过程，即 'abracadabra 为 (quote abracadabra)，因此 (car ''abracadabra) 为 (car '(quote abracadabra))，会输出 quote。
练习 56 请说明如何扩充基本求导规则，以便能够处理更多种类的表达式。例如，通过给程序 deriv 增加一个新子句，并以适当方式定义过程 exponentiation?、base、exponent 和 make-exponentiation 的方式，实现下述求导规则（你可以考虑用符号 ** 表示乘幂）：
$$ \frac{\mathrm{d}(u^n)}{\mathrm{d}x} = nu^{n-1}\left(\frac{\mathrm{d}u}{\mathrm{d}x}\right) $$
请将如下规则也构造到程序里：任何东西的 $0$ 次幂都是 $1$，而它们的 $1$ 次幂都是其自身。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #lang sicp (define (=number? exp num) (and (number? exp) (= exp num))) (define (** base exponent) (define (iter exponent r) (if (= exponent 0) r (iter (- exponent 1) (* r base)))) (iter exponent 1)) (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) ((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))) ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp)))) ((exponentiation? exp) (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1))) (deriv (base exp) var))) (else (error &#34;unknow expression type --- DERIV&#34; exp)))) (define (variable? x) (symbol? x)) (define (same-variable? v1 v2) (and (variable? v1) (variable? v2) (eq? v1 v2))) (define (make-sum a1 a2) (cond ((=number? a1 0) a2) ((=number? a2 0) a1) ((and (number? a1) (number? a2)) (+ a1 a2)) (else (list &#39;+ a1 a2)))) (define (make-product m1 m2) (cond ((or (=number? m1 0) (=number? m2 0)) 0) ((=number? m1 1) m2) ((=number? m2 1) m1) ((and (number? m1) (number? m2)) (* m1 m2)) (else (list &#39;* m1 m2)))) (define (sum? x) (and (pair? x) (eq? (car x) &#39;+))) (define (addend s) (cadr s)) (define (augend s) (caddr s)) (define (product? x) (and (pair? x) (eq? (car x) &#39;*))) (define (multiplier p) (cadr p)) (define (multiplicand p) (caddr p)) (define (make-exponentiation b e) (cond ((=number? e 0) 1) ((=number? e 1) b) ((and (number? b) (number? e)) (** b e)) (else (list &#39;** b e)))) (define (exponentiation? x) (and (pair? x) (eq? (car x) &#39;**))) (define (base e) (cadr e)) (define (exponent e) (caddr e)) ;&gt;&gt;&gt; (deriv &#39;(* (** x 3) y) &#39;x) ;: (* (* 3 (** x 2)) y) 练习 57 请扩充求导程序，使之能处理任意项（两项或者更多项）的和与乘积。这样，上面的最后一个例子就可以表示为：
1 (deriv &#39;(* x y (+ x 3)) &#39;x) 设法通过只修改和与乘积的表示，而完全不修改过程 deriv 的方式完成这一扩充。例如，让一个和式的 addend 是它的第一项，而其 augend 是和式中的其余项。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #lang sicp (define (length l) (define (iter l r) (if (null? l) r (iter (cdr l) (+ r 1)))) (iter l 0)) (define (filter predicate sequence) (cond ((null? sequence) nil) ((predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence)))) (else (filter predicate (cdr sequence))))) (define (=number? exp num) (and (number? exp) (= exp num))) (define (** base exponent) (define (iter exponent r) (if (= exponent 0) r (iter (- exponent 1) (* r base)))) (iter exponent 1)) (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) ((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))) ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp)))) ((exponentiation? exp) (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1))) (deriv (base exp) var))) (else (error &#34;unknow expression type --- DERIV&#34; exp)))) (define (variable? x) (symbol? x)) (define (same-variable? v1 v2) (and (variable? v1) (variable? v2) (eq? v1 v2))) (define (make-sum a1 . a2) (let ((a3 (filter (lambda (x) (or (pair? x) (not (=number? x 0)))) a2))) (cond ((= (length a3) 0) a1) ((= (length a3) 1) (let ((a (car a3))) (cond ((=number? a1 0) a) ((=number? a 0) a1) ((and (number? a1) (number? a)) (+ a1 a)) (else (list &#39;+ a1 a))))) (else (if (=number? a1 0) (cons &#39;+ a3) (cons &#39;+ (cons a1 a3))))))) (define (make-product m1 . m2) (let ((m3 (filter (lambda (x) (or (pair? x) (not (=number? x 1)))) m2))) (cond ((&gt; (length (filter (lambda (x) (and (not (pair? x)) (=number? x 0))) m3)) 0) 0) ((= (length m3) 0) m1) ((= (length m3) 1) (let ((m (car m3))) (cond ((or (=number? m1 0) (=number? m 0)) 0) ((=number? m1 1) m) ((=number? m 1) m1) ((and (number? m1) (number? m)) (* m1 m)) (else (list &#39;* m1 m))))) (else (cond ((=number? m1 0) 0) ((=number? m1 1) (cons &#39;* m3)) (else (cons &#39;* (cons m1 m3)))))))) (define (sum? x) (and (pair? x) (eq? (car x) &#39;+))) (define (addend s) (cadr s)) (define (augend s) (if (= (length s) 3) (caddr s) (cons &#39;+ (cddr s)))) (define (product? x) (and (pair? x) (eq? (car x) &#39;*))) (define (multiplier p) (cadr p)) (define (multiplicand p) (if (= (length p) 3) (caddr p) (cons &#39;* (cddr p)))) (define (make-exponentiation b e) (cond ((=number? e 0) 1) ((=number? e 1) b) ((and (number? b) (number? e)) (** b e)) (else (list &#39;** b e)))) (define (exponentiation? x) (and (pair? x) (eq? (car x) &#39;**))) (define (base e) (cadr e)) (define (exponent e) (caddr e)) ;&gt;&gt;&gt; (deriv &#39;(* x y (+ x 3)) &#39;x) ;: (+ (* x y) (* y (+ x 3))) 练习 58 假定我们希望修改求导程序，使它能用于常规数学公式，其中 + 和 * 采用的是中缀运算符而不是前缀。由于求导程序使基于抽象数据定义的，要修改它，使之能用于另一种不同的表达式表示，我们只需要换一套工作在新的、求导程序需要使用的代数表达式的表示形式上的谓词、选择函数和构造函数。
a) 请说明怎样做出这些过程，以便完成在中缀表示形式（例如 (x + (3 * (x + (y + 2)))) 上的代数表达式求导。为了简化有关的工作，现在可以假定 + 和 * 总是取两个参数，而且表达式中已经加上了所有的括号。
b) 如果允许标准的代数写法，例如 (x + 3 * (x + y + 2))，问题就会变得更困难许多。在这种表达式里可能不写不必要的括号。并要假定乘法应该在加法之前完成。你还能为这种表示方式设计好适当的谓词、选择函数和构造函数，使我们的求导程序仍然能工作吗？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #lang sicp (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) ((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))) ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp)))) ((exponentiation? exp) (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1))) (deriv (base exp) var))) (else (error &#34;unknow expression type --- DERIV&#34; exp)))) (define (** base exponent) (define (iter exponent r) (if (= exponent 0) r (iter (- exponent 1) (* r base)))) (iter exponent 1)) (define (=number? exp num) (and (number? exp) (= exp num))) (define (variable? v) (symbol? v)) (define (same-variable? v1 v2) (and (variable? v1) (variable? v2) (eq? v1 v2))) (define (make-sum a1 a2) (cond ((=number? a1 0) a2) ((=number? a2 0) a1) ((and (number? a1) (number? a2)) (+ a1 a2)) (else (list a1 &#39;+ a2)))) (define (sum? x) (eq? (cadr x) &#39;+)) (define (addend s) (car s)) (define (augend s) (caddr s)) (define (make-product m1 m2) (cond ((or (=number? m1 0) (=number? m2 0)) 0) ((=number? m1 1) m2) ((=number? m2 1) m1) ((and (number? m1) (number? m2)) (* m1 m2)) (else (list m1 &#39;* m2)))) (define (product? x) (eq? (cadr x) &#39;*)) (define (multiplier p) (car p)) (define (multiplicand p) (caddr p)) (define (make-exponentiation b e) (cond ((=number? e 0) 1) ((=number? e 1) b) ((and (number? b) (number? e)) (** b e)) (else (list b &#39;** e)))) (define (exponentiation? x) (eq? (cadr x) &#39;**)) (define (base e) (car e)) (define (exponent e) (caddr e)) ;&gt;&gt;&gt; (deriv &#39;(x + (3 * (x + (y + 2)))) &#39;x) ;: 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #lang sicp (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) ((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))) ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp)))) ((exponentiation? exp) (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1))) (deriv (base exp) var))) (else (error &#34;unknow expression type --- DERIV&#34; exp)))) (define (** base exponent) (define (iter exponent r) (if (= exponent 0) r (iter (- exponent 1) (* r base)))) (iter exponent 1)) (define (=number? exp num) (and (number? exp) (= exp num))) (define (variable? v) (symbol? v)) (define (same-variable? v1 v2) (and (variable? v1) (variable? v2) (eq? v1 v2))) (define (make-sum a1 a2) (cond ((=number? a1 0) a2) ((=number? a2 0) a1) ((and (number? a1) (number? a2)) (+ a1 a2)) (else (list a1 &#39;+ a2)))) (define (sum? x) (pair? (memq &#39;+ x))) (define (addend s) (let ((x (reverse (cdr (memq &#39;+ (reverse s)))))) (if (null? (cdr x)) (car x) x))) (define (augend s) (define (iter rs r) (if (eq? (car rs) &#39;+) r (iter (cdr rs) (cons (car rs) r)))) (let ((x (iter (reverse s) nil))) (if (null? (cdr x)) (car x) x))) (define (make-product m1 m2) (cond ((or (=number? m1 0) (=number? m2 0)) 0) ((=number? m1 1) m2) ((=number? m2 1) m1) ((and (number? m1) (number? m2)) (* m1 m2)) (else (list m1 &#39;* m2)))) (define (product? x) (pair? (memq &#39;* x))) (define (multiplier p) (let ((x (reverse (cdr (memq &#39;* (reverse p)))))) (if (null? (cdr x)) (car x) x))) (define (multiplicand p) (define (iter rp r) (if (eq? (car rp) &#39;*) r (iter (cdr rp) (cons (car rp) r)))) (let ((x (iter (reverse p) nil))) (if (null? (cdr x)) (car x) x))) (define (make-exponentiation b e) (cond ((=number? e 0) 1) ((=number? e 1) b) ((and (number? b) (number? e)) (** b e)) (else (list b &#39;** e)))) (define (exponentiation? x) (pair? (memq &#39;** x))) (define (base e) (let ((x (reverse (cdr (memq &#39;** (reverse e)))))) (if (null? (cdr x)) (car x) x))) (define (exponent e) (define (iter re r) (if (eq? (car re) &#39;**) r (iter (cdr re) (cons (car re) r)))) (let ((x (iter (reverse e) nil))) (if (null? (cdr x)) (car x) x))) ;&gt;&gt;&gt; (deriv &#39;(x + 3 * (x + y + 2)) &#39;x) ;: 4 练习 59 请为采用未排序表的集合实现定义 union-set 操作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 #lang sicp (define (element-of-set? x set) (cond ((null? set) #f) ((equal? x (car set)) #t) (else (element-of-set? x (cdr set))))) (define (union-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) ((element-of-set? (car set1) set2) (union-set (cdr set1) set2)) (else (cons (car set1) (union-set (cdr set1) set2))))) 练习 60 我们前面说明了如何将集合表示为没有重复元素的表。现在假定允许重复，例如，集合 ${1, 2, 3}$ 可能被表示为表 (2 3 2 1 3 2 2)。请为在这种表示上的操作设计过程 element-of-set?、adjoin-set、union-set、和 intersection-set。与前面不重复表示里的相应操作相比，现在各个操作的效率怎么样？在什么样的应用中你更倾向于使用这种表示，而不是前面那种无重复的表示？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #lang sicp (define (element-of-set? x set) (cond ((null? set) #f) ((equal? x (car set)) #t) (else (element-of-set? x (cdr set))))) (define (adjoin-set x set) (cons x set)) (define (intersection-set set1 set2) (cond ((or (null? set1) (null? set2)) &#39;()) ((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))) (else (intersection-set (cdr set1) set2)))) (define (union-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) (else (cons (car set1) (union-set (cdr set1) set2))))) 允许重复的情况下，过程 element-of-set? 的效率变化无法确定；由于过程 adjoin-set 和 union-set 不再需要使用 element-of-set?，因此效率会提高；而 intersection-set 由于需要处理更长的表，效率会下降。在需要添加元素或是取并频繁的应用中使用这种表示效率更高。
练习 61 请给出采用排序表示时 adjoin-set 的实现。通过类似 element-of-set? 的方式说明，可以如何利用排序的优势得到一个过程，其平均所需的步数是采用未排序表示时的一半。
将待插入元素依次与集合中元素比较，如果待插入元素大于当前元素，继续比较下一个；如果等于当前元素，不必插入；如果小于当前元素，插入到该位置。该表示下平均所需的步数是采用未排序表示时的一半。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #lang sicp (define (adjoin-set x set) (cond ((null? set) (list x)) ((&lt; (car set) x) (cons (car set) (adjoin-set x (cdr set)))) ((= (car set) x) set) (else (cons x set)))) ;&gt;&gt;&gt; (adjoin-set -10 (list 1 5 7 13)) ;: (-10 1 5 7 13) ;&gt;&gt;&gt; (adjoin-set 5 (list 1 5 7 13)) ;: (1 5 7 13) ;&gt;&gt;&gt; (adjoin-set 8 (list 1 5 7 13)) ;: (1 5 7 8 13) ;&gt;&gt;&gt; (adjoin-set 991 (list 1 5 7 13)) ;: (1 5 7 13 991) 练习 62 请给出在集合的排序表示上 union-set 的一个 $\Theta(n)$ 实现。
1 2 3 4 5 6 7 8 9 10 11 12 13 #lang sicp (define (union-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) (else (let ((x1 (car set1)) (x2 (car set2))) (cond ((= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2)))) ((&lt; x1 x2) (cons x1 (union-set (cdr set1) set2))) (else (cons x2 (union-set set1 (cdr set2))))))))) 练习 63 下面两个过程都能将树变换为表：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #lang sicp (define (tree-&gt;list-1 tree) (if (null? tree) &#39;() (append (tree-&gt;list-1 (left-branch tree)) (cons (entry tree) (tree-&gt;list-1 (right-branch tree)))))) (define (tree-&gt;list-2 tree) (define (copy-to-list tree result-list) (if (null? tree) result-list (copy-to-list (left-branch tree) (cons (entry tree) (copy-to-list (right-branch tree) result-list))))) (copy-to-list tree &#39;())) a) 这两个过程对所有的树都产生同样结果吗？如果不是，它们产生出的结果有什么不同？它们对图 2-16 中的那些树产生什么样的表？
b) 将 $n$ 个结点的平衡树变换为表时，这两个过程所需的步数具有同样量级的增长速度吗？如果不一样，哪个过程增长得慢一些？
结果相同，对图 2-16 中的树产生的表均为 (1 3 5 7 9 11)。
不同，tree-&gt;list-1 慢一些。因为 tree-&gt;list-1 中的 append 会将复杂度提升 $n$ 倍。
练习 64 下面过程 list-&gt;tree 将一个有序表变换为一棵平衡二叉树。其中的辅助函数 partial-tree 以整数 $n$ 和一个至少包含 $n$ 个元素的表为参数，构造出一棵包含这个表的前 $n$ 个元素的平衡树。由 partial-tree 返回的结果是一个序对（用 cons 构造），其 car 是构造出的树，其 cdr 是没有包含在树种那些元素的表。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 (define (list-&gt;tree elements) (car (partial-tree elements (length elements)))) (define (partial-tree elts n) (if (= n 0) (cons &#39;() elts) (let ((left-size (quotient (- n 1) 2))) (let ((left-result (partial-tree elts left-size))) (let ((left-tree (car left-result)) (non-left-elts (cdr left-result)) (right-size (- n (+ left-size 1)))) (let ((this-entry (car non-left-elts)) (right-result (partial-tree (cdr non-left-elts) right-size))) (let ((right-tree (car right-result)) (remaining-elts (cdr right-result))) (cons (make-tree this-entry left-tree right-tree) remaining-elts)))))))) a) 请简要地并尽可能清楚地解释为什么 partial-tree 能完成工作。请画出将 list-&gt;tree 用于表 (1 3 5 7 9 11) 产生出的树。
b) 过程 list-&gt;tree 转换 $n$ 个元素的表所需的步数以什么量级增长？
对于一个 list，首先计算出构造左子树和右子树需要的结点数，然后用所需结点递归地调用 partial-tree 构造子树，最后用生成的子树和根结点构造树。list-&gt;tree 用于表 (1 3 5 7 9 11) 产生出的树为：
partial-tree 访问每个结点恰好一次，将其设置为跟结点，其余操作均为常数级复杂度，因此步数为 $\Theta(n)$。
练习 65 利用 练习 63 和 练习 64 的结果，给出对采用（平衡）二叉树方式实现的集合的 union-set 和 intersection-set 操作的 $\Theta(n)$ 实现。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #lang sicp (define (make-tree entry left right) (list entry left right)) (define (entry tree) (car tree)) (define (left-branch tree) (cadr tree)) (define (right-branch tree) (caddr tree)) (define (tree-&gt;list tree) (define (copy-to-list tree result-list) (if (null? tree) result-list (copy-to-list (left-branch tree) (cons (entry tree) (copy-to-list (right-branch tree) result-list))))) (copy-to-list tree &#39;())) (define (list-&gt;tree elements) (car (partial-tree elements (length elements)))) (define (partial-tree elts n) (if (= n 0) (cons &#39;() elts) (let ((left-size (quotient (- n 1) 2))) (let ((left-result (partial-tree elts left-size))) (let ((left-tree (car left-result)) (non-left-elts (cdr left-result)) (right-size (- n (+ left-size 1)))) (let ((this-entry (car non-left-elts)) (right-result (partial-tree (cdr non-left-elts) right-size))) (let ((right-tree (car right-result)) (remaining-elts (cdr right-result))) (cons (make-tree this-entry left-tree right-tree) remaining-elts)))))))) (define (union-set set1 set2) (define (union-set-list set1 set2) (cond ((null? set1) set2) ((null? set2) set1) (else (let ((x1 (car set1)) (x2 (car set2))) (cond ((= x1 x2) (cons x1 (union-set-list (cdr set1) (cdr set2)))) ((&lt; x1 x2) (cons x1 (union-set-list (cdr set1) set2))) (else (cons x2 (union-set-list set1 (cdr set2))))))))) (list-&gt;tree (union-set-list (tree-&gt;list set1) (tree-&gt;list set2)))) (define (intersection-set set1 set2) (define (intersection-set-list set1 set2) (if (or (null? set1) (null? set2)) &#39;() (let ((x1 (car set1)) (x2 (car set2))) (cond ((= x1 x2) (cons x1 (intersection-set-list (cdr set1) (cdr set2)))) ((&lt; x1 x2) (intersection-set-list (cdr set1) set2)) (else (intersection-set-list set1 (cdr set2))))))) (list-&gt;tree (intersection-set-list (tree-&gt;list set1) (tree-&gt;list set2)))) ;&gt;&gt;&gt; (define s1 (list-&gt;tree &#39;(1 2 3 5 6 8 10 11))) ;&gt;&gt;&gt; (define s2 (list-&gt;tree &#39;(2 4 6 8 11 13))) ;&gt;&gt;&gt; (tree-&gt;list (union-set s1 s2)) ;: (1 2 3 4 5 6 8 10 11 13) ;&gt;&gt;&gt; (tree-&gt;list (intersection-set s1 s2)) ;: (2 6 8 11) 练习 66 假设记录的集合采用二叉树实现，按照其中作为键值的数值排序。请实现相应的 lookup 过程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #lang sicp (define (key record) (car record)) (define (left-branch tree) (cadr tree)) (define (right-branch tree) (caddr tree)) (define (lookup given-key set-of-records) (cond ((null? set-of-records) false) ((&lt; given-key (key (car set-of-records))) (lookup given-key (left-branch set-of-records))) ((= given-key (key (car set-of-records))) (car set-of-records)) (else (lookup given-key (right-branch set-of-records))))) 练习 67 请定义一棵编码树和一个样例消息：
1 2 3 4 5 6 7 8 (define sample-tree (make-code-tree (make-leaf &#39;A 4) (make-code-tree (make-leaf &#39;B 2) (make-code-tree (make-leaf &#39;D 1) (make-leaf &#39;C 1))))) (define sample-message &#39;(0 1 1 0 0 1 0 1 0 1 1 1 0)) 然后用过程 decode 完成该消息的编码，给出编码的结果。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #lang sicp (define (make-leaf symbol weight) (list &#39;leaf symbol weight)) (define (leaf? object) (eq? (car object) &#39;leaf)) (define (symbol-leaf x) (cadr x)) (define (weight-leaf x) (caddr x)) (define (make-code-tree left right) (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right)))) (define (left-branch tree) (car tree)) (define (right-branch tree) (cadr tree)) (define (symbols tree) (if (leaf? tree) (list (symbol-leaf tree)) (caddr tree))) (define (weight tree) (if (leaf? tree) (weight-leaf tree) (cadddr tree))) (define (decode bits tree) (define (decode-1 bits current-branch) (if (null? bits) &#39;() (let ((next-branch (choose-branch (car bits) current-branch))) (if (leaf? next-branch) (cons (symbol-leaf next-branch) (decode-1 (cdr bits) tree)) (decode-1 (cdr bits) next-branch))))) (decode-1 bits tree)) (define (choose-branch bit branch) (cond ((= bit 0) (left-branch branch)) ((= bit 1) (right-branch branch)) (else (error &#34;bad bit -- CHOOSE-BRANCH&#34; bit)))) #;(define sample-tree (make-code-tree (make-leaf &#39;A 4) (make-code-tree (make-leaf &#39;B 2) (make-code-tree (make-leaf &#39;D 1) (make-leaf &#39;C 1))))) ;&gt;&gt;&gt; (define sample-message &#39;(0 1 1 0 0 1 0 1 0 1 1 1 0)) ;&gt;&gt;&gt; (decode sample-message sample-tree) ;: (A D A B B C A) 练习 68 过程 encode 以一个消息和一棵树为参数，产生出被编码消息所对应的二进制位的表：
1 2 3 4 5 (define (encode message tree) (if (null? message) &#39;() (append (encode-symbol (car message) tree) (encode (cdr message) tree)))) 其中的 encode-symbol 是需要你写出的过程，它能根据给定的树产生出给定符号的二进制位表。你所设计的 encode-symbol 在遇到未出现在树中的符号时应报告错误。请用在 练习 2.67 中得到的结果检查所实现的过程，工作中用同样一棵树，看看得到的结果是不是原来那个消息。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #lang sicp (define (make-leaf symbol weight) (list &#39;leaf symbol weight)) (define (leaf? object) (eq? (car object) &#39;leaf)) (define (symbol-leaf x) (cadr x)) (define (weight-leaf x) (caddr x)) (define (make-code-tree left right) (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right)))) (define (left-branch tree) (car tree)) (define (right-branch tree) (cadr tree)) (define (symbols tree) (if (leaf? tree) (list (symbol-leaf tree)) (caddr tree))) (define (weight tree) (if (leaf? tree) (weight-leaf tree) (cadddr tree))) (define (encode message tree) (if (null? message) &#39;() (append (encode-symbol (car message) tree) (encode (cdr message) tree)))) (define (encode-symbol symbol tree) (cond ((not (memq symbol (symbols tree))) (error &#34;bad symbol -- ENCODE-SYMBOL&#34; symbol)) ((leaf? tree) &#39;()) (else (if (memq symbol (symbols (left-branch tree))) (cons &#39;0 (encode-symbol symbol (left-branch tree))) (cons &#39;1 (encode-symbol symbol (right-branch tree))))))) #;(define sample-tree (make-code-tree (make-leaf &#39;A 4) (make-code-tree (make-leaf &#39;B 2) (make-code-tree (make-leaf &#39;D 1) (make-leaf &#39;C 1))))) ;&gt;&gt;&gt; (define sample-message &#39;(A D A B B C A)) ;&gt;&gt;&gt; (encode sample-message sample-tree) ;: (0 1 1 0 0 1 0 1 0 1 1 1 0) 练习 69 下面过程以一个符号 &mdash; 频度对偶表为参数（其中没有任何符号出现在多于一个对偶中），并根据 Huffman 算法生成出 Huffman 编码树。
1 2 (define (generate-huffman-tree pairs) (successive-merge (make-leaf-set pairs))) 其中的 make-leaf-set 是前面给出的过程，它将对偶表转换为叶的有序集，successive-merge 是需要你写的过程，它使用 make-code-tree 反复归并集合中具有最小权重的元素，直至集合里只剩下一个元素为止。这个元素就是我们所需要的 Huffman 树。（这一过程稍微有点技巧性，但并不很复杂。如果你正在设计的过程变得复杂，那么几乎可以肯定是在什么地方搞错了。你应该尽可能地利用有序集合表示这一事实。）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #lang sicp (define (make-leaf symbol weight) (list &#39;leaf symbol weight)) (define (leaf? object) (eq? (car object) &#39;leaf)) (define (symbol-leaf x) (cadr x)) (define (weight-leaf x) (caddr x)) (define (make-code-tree left right) (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right)))) (define (left-branch tree) (car tree)) (define (right-branch tree) (cadr tree)) (define (symbols tree) (if (leaf? tree) (list (symbol-leaf tree)) (caddr tree))) (define (weight tree) (if (leaf? tree) (weight-leaf tree) (cadddr tree))) (define (adjoin-set x set) (cond ((null? set) (list x)) ((&lt; (weight x) (weight (car set))) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set)))))) (define (make-leaf-set pairs) (if (null? pairs) &#39;() (let ((pair (car pairs))) (adjoin-set (make-leaf (car pair) (cadr pair)) (make-leaf-set (cdr pairs)))))) (define (generate-huffman-tree pairs) (successive-merge (make-leaf-set pairs))) (define (successive-merge tree-set) (if (= (length tree-set) 1) (car tree-set) (successive-merge (adjoin-set (make-code-tree (car tree-set) (cadr tree-set)) (cddr tree-set))))) ;&gt;&gt;&gt; (generate-huffman-tree &#39;((A 4) (B 2) (C 1) (D 1))) #; ((leaf A 4) ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4) (A B D C) 8) 练习 70 下面带有相对频度的 8 个符号的字母表，是为了有效编码 20 世纪 50 年代的摇滚歌曲中的词语而设计的。（请注意，“字母表”中的“符号”不必是单个字母。）
A | 2 | NA | 16
BOOM | 1 | SHA | 3
GET | 2 | YIP | 9
JOB | 2 | WAH | 1
请用（ 练习 69 的）generate-huffman-tree 过程生成对应的 Huffman 树，用（ 练习 68 的）encode 过程编码下面的消息：
Get a job
Sha na na na na na na na na
Get a job
Sha na na na na na na na na
Wah yip yip yip yip yip yip yip yip yip
Sha boom
这一编码需要多少个二进制位？如果对这 8 个符号的字母表采用定长编码，完成这个歌曲的编码最少需要多少个二进制位？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #lang sicp (define (make-leaf symbol weight) (list &#39;leaf symbol weight)) (define (leaf? object) (eq? (car object) &#39;leaf)) (define (symbol-leaf x) (cadr x)) (define (weight-leaf x) (caddr x)) (define (make-code-tree left right) (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right)))) (define (left-branch tree) (car tree)) (define (right-branch tree) (cadr tree)) (define (symbols tree) (if (leaf? tree) (list (symbol-leaf tree)) (caddr tree))) (define (weight tree) (if (leaf? tree) (weight-leaf tree) (cadddr tree))) (define (encode message tree) (if (null? message) &#39;() (append (encode-symbol (car message) tree) (encode (cdr message) tree)))) (define (encode-symbol symbol tree) (cond ((not (memq symbol (symbols tree))) (error &#34;bad symbol -- ENCODE-SYMBOL&#34; symbol)) ((leaf? tree) &#39;()) (else (if (memq symbol (symbols (left-branch tree))) (cons &#39;0 (encode-symbol symbol (left-branch tree))) (cons &#39;1 (encode-symbol symbol (right-branch tree))))))) (define (adjoin-set x set) (cond ((null? set) (list x)) ((&lt; (weight x) (weight (car set))) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set)))))) (define (make-leaf-set pairs) (if (null? pairs) &#39;() (let ((pair (car pairs))) (adjoin-set (make-leaf (car pair) (cadr pair)) (make-leaf-set (cdr pairs)))))) (define (generate-huffman-tree pairs) (successive-merge (make-leaf-set pairs))) (define (successive-merge tree-set) (if (= (length tree-set) 1) (car tree-set) (successive-merge (adjoin-set (make-code-tree (car tree-set) (cadr tree-set)) (cddr tree-set))))) #; (define sample-pairs &#39;((A 2) (NA 16) (BOOM 1) (SHA 3) (GET 2) (YIP 9) (JOB 2) (WAH 1))) #; (define sample-message &#39;(GET A JOB SHA NA NA NA NA NA NA NA NA GET A JOB SHA NA NA NA NA NA NA NA NA WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP SHA BOOM)) ;&gt;&gt;&gt; (generate-huffman-tree sample-pairs) #; ((leaf NA 16) ((leaf YIP 9) (((leaf A 2) ((leaf WAH 1) (leaf BOOM 1) (WAH BOOM) 2) (A WAH BOOM) 4) ((leaf SHA 3) ((leaf JOB 2) (leaf GET 2) (JOB GET) 4) (SHA JOB GET) 7) (A WAH BOOM SHA JOB GET) 11) (YIP A WAH BOOM SHA JOB GET) 20) (NA YIP A WAH BOOM SHA JOB GET) 36) ;&gt;&gt;&gt; (encode sample-message (generate-huffman-tree sample-pairs)) ;: (1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1) Huffman 编码需要 84 个二进制位，采用定长编码，每个单词至少需要 3 个二进制位，总共 36 个单词，供 108 位。
练习 71 假定我们有一棵 $n$ 个符号的字母表的 Huffman 树，其中各符号的相对频度分别是 $1, 2, 4, \cdots, 2^{n-1}$。请对 $n=5$ 和 $n=10$ 勾勒出有关的树的样子。对于这样的树（对于一般的 $n$），编码出现最频繁的符号用多少个二进制位？最不频繁的符号呢？
树的每个非叶结点至少有一棵子树为叶结点，最频繁的符号用 $1$ 个二进制位，最不频繁的符号用 $n-1$ 个二进制位。
练习 72 考虑你在 练习 68 中设计的编码过程。对于一个符号的编码，计算步数的增长速率是什么？请注意，这时需要把在每个结点中检查符号表所需的步数包括在内。一般性地回答这一问题是非常困难的。现在考虑一类特殊情况，其中的 $n$ 个符号的相对频度如 练习 71 所描述的。请给出编码最频繁的符号所需的步数和最不频繁的符号所需的步数的增长速度（作为 $n$ 的函数）。
判断符号在编码树中 $\Theta(n)$，树的平均深度 $\log(n)$，增长速率 $\Theta(n\log(n))$。
在 练习 71 中，最好的情况下，搜索深度为 $1$，最坏的情况为 $n-1$，因此所需的步数分别为 $\Theta(n)$、$\Theta(n^2)$。
练习 73 2.3.2 节描述了一个执行符号求导的程序：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) ((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))) ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp)))) (else (error &#34;unknown exporession type -- DERIV&#34; exp)))) 可以认为，这个程序是在执行一种基于被求导表达式类型的分派工作。在这里，数据的“类型标志”就是代数运算符（例如 +），需要执行的操作是 deriv。我们也可以将这一程序变换到数据导向的风格，将基本求导过程重新写成：
1 2 3 4 5 6 7 8 9 (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) (else ((get &#39;deriv (operator exp)) (operands exp) var)))) (define (operator exp) (car exp)) (define (operands exp) (cdr exp)) a) 请解释上面究竟做了些什么。为什么我们无法将相近的谓词 number? 和 same-variable? 也加入数据导向分派中？
b) 请写出针对和式与积式的求导过程，并把它们安装到表格里，以便上面程序使用所需要的辅助性代码。
c) 请选择一些你希望包括的求导规则，例如对乘幂（练习 2.56）求导等等，并将它们安装到这一数据导向的系统里。
d) 在这一简单的代数运算器中，表达式的类型就是构造起它们来的代数运算符。假定我们想以另一种相反的方式做索引，使得 deriv 里完成分派的代码行像下面这样：
1 ((get (operator exp) &#39;deriv) (operands exp) var) 求导系统里还需要做哪些相应的改动？
上面的代码根据表达式的类型选择相应的求导过程处理表达式。number? 和 same-variable? 由于没有运算符，无法判断表达式类型，即无法调用 operator 过程，需要单独处理。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 #lang sicp (define (make-table) (let ((local-table (list &#39;*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) &#39;ok) (define (dispatch m) (cond ((eq? m &#39;lookup-proc) lookup) ((eq? m &#39;insert-proc!) insert!) (else (error &#34;Unknown operation -- TABLE&#34; m)))) dispatch)) (define operation-table (make-table)) (define get (operation-table &#39;lookup-proc)) (define put (operation-table &#39;insert-proc!)) (define (variable? x) (symbol? x)) (define (same-variable? x v) (eq? x v)) (define (=number? x num) (and (number? x) (= x num))) (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) (else ((get &#39;deriv (operator exp)) (operands exp) var)))) (define (operator exp) (car exp)) (define (operands exp) (cdr exp)) (define (install-sum-package) (define (make-sum a1 a2) (cond ((=number? a1 0) a2) ((=number? a2 0) a1) ((and (number? a1) (number? a2)) (+ a1 a2)) (else (list &#39;+ a1 a2)))) (define (addend operands) (car operands)) (define (augend operands) (cadr operands)) (define (deriv-sum operands var) (make-sum (deriv (addend operands) var) (deriv (augend operands) var))) (put &#39;make &#39;+ make-sum) (put &#39;deriv &#39;+ deriv-sum) (display &#34;Install sum package done\n&#34;)) (define (make-sum a1 a2) ((get &#39;make &#39;+) a1 a2)) (define (install-product-package) (define (make-product m1 m2) (cond ((or (=number? m1 0) (=number? m2 0)) 0) ((=number? m1 1) m2) ((=number? m2 1) m1) (else (list &#39;* m1 m2)))) (define (multiplier operands) (car operands)) (define (multiplicand operands) (cadr operands)) (define (deriv-product operands var) (make-sum (make-product (multiplier operands) (deriv (multiplicand operands) var)) (make-product (deriv (multiplier operands) var) (multiplicand operands)))) (put &#39;make &#39;* make-product) (put &#39;deriv &#39;* deriv-product) (display &#34;Install product package done\n&#34;)) (define (make-product m1 m2) ((get &#39;make &#39;*) m1 m2)) (define (** base exponent) (if (= exponent 0) 1 (* base (** base (- exponent 1))))) (define (install-exponentiation-package) (define (make-exponentiation b e) (cond ((=number? e 0) 1) ((=number? e 1) b) ((and (number? b) (number? e)) (** b e)) (else (list &#39;** b e)))) (define (base operands) (car operands)) (define (exponent operands) (cadr operands)) (define (deriv-exponentiation operands var) (make-product (make-product (exponent operands) (make-exponentiation (base operands) (- (exponent operands) 1))) (deriv (base operands) var))) (put &#39;make &#39;** make-exponentiation) (put &#39;deriv &#39;** deriv-exponentiation) (display &#34;Install exponentiation package done\n&#34;)) (define (make-exponentiation b e) ((get &#39;make &#39;**) b e)) (install-sum-package) (install-product-package) (install-exponentiation-package) ;&gt;&gt;&gt; (deriv &#39;(+ (* x x) (* 2 (** x 3))) &#39;x) ;: (+ (+ x x) (* 2 (* 3 (** x 2)))) put 过程调用时前两个参数调换一下即可。
练习 74 Insatiable Enterprise 公司是一个高度分散经营的联合公司，由大量分布在世界各地的分支机构组成。公司的计算机设施已经通过一种非常巧妙的网络连接模式联为一体，它使得从任何一个用户的角度看，整个网络就像是一台计算机。在第一次试图利用网络能力从各分支机构的文件中提取管理信息时，Insatiable 的总经理非常沮丧地发现，虽然所有分支机构的文件都被实现为 Scheme 的数据结构，但是各分支机构所用的数据结构却各不相同。她马上招集了各分支机构的经理会议，希望寻找一种策略集成起这些文件，以便在维持各个分支机构中现存独立工作方式的同时，又能满足公司总部管理的需要。
请说明这种策略可以如何通过数据导向的程序设计技术实现。作为例子，假定每个分支机构的人事记录都存放在一个独立文件里，其中包含了一集以雇员名字作为键值的记录。而有关集合的结构却由于分支机构的不同而不同。进一步说，某个雇员的记录本身又是一个集合（各分支机构所用的结构也不同），其中所包含的信息也在一些作为键值的标识符之下，例如 address 和 salary。特别是考虑如下问题：
a) 请为公司总部实现一个 get-record 过程，使它能从一个特定的人事文件里提取出一个特定的雇员记录。这一过程应该能应用于任何分支机构的文件。请说明各个独立分支机构的文件应具有怎样的结构。特别是考虑，它们必须提供哪些类型信息。
b) 请为公司总部实现一个 get-salary 过程，它能从任何分支机构的人事文件中取得某个给定雇员的薪金信息。为了使这个操作能够工作，这些记录应具有怎样的结构？
c) 请为公司总部实现一个过程 find-employee-record，该过程需要针对一个特定雇员名，在所有分支机构的文件查找对应的记录，并返回找到的记录。假定这一过程的参数是一个雇员名和所有分支文件的表。
d) 当 Insatiable 购并新公司后，要将新的人事文件结合到系统中，必须做哪些修改。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #lang sicp (define (get-record employee-name personnel-file) (let ((record ((get &#39;get-record (type-tag personnel-file)) employee-name (contents personnel-file)))) (if record (attach-tag (type-tag personnel-file) record) #f))) (define (get-salary record) ((get &#39;get-salary (type-tag record)) (contents record))) (define (find-employee-record employee-name personnel-files) (if (null? personnel-files) #f (let ((record (get-record employee-name (car personnel-files)))) (if record record (find-employee-record employee-name (cdr personnel-files)))))) 练习 75 请用消息传递的风格实现构造函数 make-from-mag-ang。这一过程应该与上面给出的 make-from-real-imag 过程类似。
1 2 3 4 5 6 7 8 9 10 11 #lang sicp (define (make-from-mag-ang magnitude angle) (define (dispatch op) (cond ((eq? op &#39;real-part) (* magnitude (cos angle))) ((eq? op &#39;imag-part) (* magnitude (sin angle))) ((eq? op &#39;magnitude) magnitude) ((eq? op &#39;angle) angle) (else (error &#34;Unknown op -- MAKE-FROM-MAG-ANG&#34; op)))) dispatch) 练习 76 一个带有通用型操作的大型系统可能不断演化，在演化中常需要加入新的数据对象类型或者新的操作。对于上面提出的三种策略 &mdash;&mdash; 带有显式分派的通用型操作，数据导向的风格，以及消息传递的风格 &mdash;&mdash; 请描述在加入一个新类型或者新操作时，系统所必须做的修改。哪种组织方式最适合哪些经常需要加入新类型的系统？哪种组织方式最适合哪些经常加入新操作的系统？
策略 新类型 新操作 显式分派 创建新的命名不冲突的过程并修改通用型过程适配新类型 在每个类型中添加新操作并创建通用型操作 数据导向 创建新的过程并安装到操作表中 在每个类型中添加新操作并安装到操作表中 消息传递 创建新的过程 在每个类型中添加新操作 两种情况消息传递均最为合适。
练习 77 Louis Reasoner 试着去求值 (magnitude z)，其中的 z 就是图 2-24 里的那个对象。令他吃惊的是，从 apply-generic 出来的不是 5 而是一个错误信息，说没办法对类型 (complex) 做操作 magnitude。他将这次交互的情况给 Alyssa P. Hacker 看，Alyssa 说“问题出在没有为 complex 数定义复数选择函数，而只是为 polar 和 rectangular 数定义了它们。你需要做的就是在 complex 包里加入下面这些东西”：
1 2 3 4 5 6 7 (put &#39;real-part &#39;(complex) real-part) (put &#39;imag-part &#39;(complex) imag-part) (put &#39;magnitude &#39;(complex) magnitude) (put &#39;angle &#39;(complex) angle) 请详细说明为什么这样做是可行的。作为一个例子，请考虑表达式 (magnitude z) 的求值过程，其中 z 就是图 2-24 里展示的那个对象，请追踪一下这一求值过程中的所有函数调用。特别是看看 apply-generic 被调用了几次？每次调用中分派的是哪个过程？
因为 z 的最外层标志位 complex，原有操作表中没有 magnitude 与 complex 的组合，因此查找失败；添加之后，调用 (magnitude z) 的话会逐层传递到 rectangular 的 magnitude 过程。
1 2 3 4 5 6 7 (magnitude z) ; call (apply-generic &#39;magnitude z) ((get &#39;magnitude &#39;(complex)) (contents z)) (magnitude (contents z)) ; complex (apply-generic &#39;magnitude (contents z)) ((get &#39;magnitude &#39;(rectangular)) (contents (contents z))) (magnitude (contents (contents z))) ; rectangular apply-generic 被调用了两次，第一次被分配给 complex 的 magnitude 过程，第二次被分配给 rectangular 的 maginitude 过程。
练习 78 包 scheme-number 里的内部过程几乎什么也没做，只不过是去调用基本过程 +、- 等等。直接使用语言的基本过程当然是不可能的，因为我们的数据类型标志系统要求每个数据对象都附加一个类型。然而，事实上所有 Lisp 实现都有自己的类型系统，使用在系统实现的内部，基本谓词 symbol? 和 number? 等用于确定每个数据对象是否具有特定的类型。请修改 2.4.2 节中 type-tag、contents 和 attach-tag 的定义，使我们的通用算术系统可以利用 Scheme 的内部类型系统。这也就是说，修改后的系统应该像原来一样工作，除了其中常规的数直接采用 Scheme 的数形式，而不是表示为一个 car 部分是符号 scheme-number 的序对。
见 练习 80 。
练习 79 请定义一个通用型相等谓词 equ?，它能检查两个数是否相等。请将它安装到通用算术包里。这一操作应该能处理常规的数、有理数和复数。
见 练习 80 。
练习 80 请定义一个通用谓词 =zero?，检查其参数是否为 0，并将它安装到通用算术包里。这一操作应该能处理常规的数、有理数和复数。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 #lang sicp (define (make-table) (let ((local-table (list &#39;*table*))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) &#39;ok) (define (dispatch m) (cond ((eq? m &#39;lookup-proc) lookup) ((eq? m &#39;insert-proc!) insert!) (else (error &#34;Unknown operation -- TABLE&#34; m)))) dispatch)) (define operation-table (make-table)) (define get (operation-table &#39;lookup-proc)) (define put (operation-table &#39;insert-proc!)) (define (attach-tag type-tag contents) (if (pair? contents) (cons type-tag contents) contents)) (define (type-tag datum) (if (pair? datum) (car datum) &#39;scheme-number)) (define (contents datum) (if (pair? datum) (cdr datum) datum)) (define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (error &#34;No method for these types -- APPLY-GENERIC&#34; (list op type-tags)))))) (define (add x y) (apply-generic &#39;add x y)) (define (sub x y) (apply-generic &#39;sub x y)) (define (mul x y) (apply-generic &#39;mul x y)) (define (div x y) (apply-generic &#39;div x y)) (define (equ? x y) (apply-generic &#39;equ? x y)) (define (=zero? x) (apply-generic &#39;=zero? x)) (define (install-scheme-number-package) (define (tag x) (attach-tag &#39;scheme-number x)) (put &#39;equ? &#39;(scheme-number scheme-number) (lambda (x y) (tag (= x y)))) (put &#39;=zero? &#39;(scheme-number) (lambda (x) (tag (= x 0)))) (put &#39;add &#39;(scheme-number scheme-number) (lambda (x y) (tag (+ x y)))) (put &#39;sub &#39;(scheme-number scheme-number) (lambda (x y) (tag (- x y)))) (put &#39;mul &#39;(scheme-number scheme-number) (lambda (x y) (tag (* x y)))) (put &#39;div &#39;(scheme-number scheme-number) (lambda (x y) (tag (/ x y)))) (put &#39;make &#39;scheme-number (lambda (x) (tag x))) &#39;done) (define (make-scheme-number n) ((get &#39;make &#39;scheme-number) n)) (define (install-rational-package) ;; internal procedures (define (numer x) (car x)) (define (denom x) (cdr x)) (define (make-rat n d) (let ((g (gcd n d))) (cons (/ n g) (/ d g)))) (define (add-rat x y) (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y)))) (define (sub-rat x y) (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y)))) (define (mul-rat x y) (make-rat (* (numer x) (numer y)) (* (denom x) (denom y)))) (define (div-rat x y) (make-rat (* (numer x) (denom y)) (* (denom x) (numer y)))) (define (equ? x y) (and (= (numer x) (numer y)) (= (denom x) (denom y)))) (define (=zero? x) (= (numer x) 0)) ;; interface to rest of the system (define (tag x) (attach-tag &#39;rational x)) (put &#39;add &#39;(rational rational) (lambda (x y) (tag (add-rat x y)))) (put &#39;sub &#39;(rational rational) (lambda (x y) (tag (sub-rat x y)))) (put &#39;mul &#39;(rational rational) (lambda (x y) (tag (mul-rat x y)))) (put &#39;div &#39;(rational rational) (lambda (x y) (tag (div-rat x y)))) (put &#39;equ? &#39;(rational rational) (lambda (x y) (tag (equ? x y)))) (put &#39;=zero? &#39;(rational) (lambda (x) (tag (=zero? x)))) (put &#39;make &#39;rational (lambda (n d) (tag (make-rat n d)))) &#39;done) (define (make-rat n d) ((get &#39;make &#39;rational) n d)) (define (square x) (* x x)) (define (install-rectangular-package) (define (real-part z) (car z)) (define (imag-part z) (cdr z)) (define (make-from-real-imag x y) (cons x y)) (define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z))))) (define (angle z) (atan (imag-part z) (real-part z))) (define (make-from-mag-ang r a) (cons (* r (cos a)) (* (r (sin a))))) (define (tag x) (attach-tag &#39;rectangular x)) (put &#39;real-part &#39;(rectangular) real-part) (put &#39;imag-part &#39;(rectangular) imag-part) (put &#39;magnitude &#39;(rectangular) magnitude) (put &#39;angle &#39;(rectangular) angle) (put &#39;make-from-real-imag &#39;rectangular (lambda (x y) (tag (make-from-real-imag x y)))) (put &#39;make-from-mag-ang &#39;rectangular (lambda (r a) (tag (make-from-mag-ang r a)))) &#39;done) (define (install-polar-package) (define (magnitude z) (car z)) (define (angle z) (cdr z)) (define (make-from-mag-ang r a) (cons r a)) (define (real-part z) (* (magnitude z) (cos (angle z)))) (define (imag-part z) (* (magnitude z) (sin (angle z)))) (define (make-from-real-imag x y) (cons (sqrt (+ (square x) (square y))) (atan y x))) (define (tag x) (attach-tag &#39;polar x)) (put &#39;real-part &#39;(polar) real-part) (put &#39;imag-part &#39;(polar) imag-part) (put &#39;magnitude &#39;(polar) magnitude) (put &#39;angle &#39;(polar) angle) (put &#39;make-from-real-imag &#39;polar (lambda (x y) (tag (make-from-real-imag x y)))) (put &#39;make-from-mag-ang &#39;polar (lambda (r a) (tag (make-from-mag-ang r a)))) &#39;done) (define (real-part z) (apply-generic &#39;real-part z)) (define (imag-part z) (apply-generic &#39;imag-part z)) (define (magnitude z) (apply-generic &#39;magnitude z)) (define (angle z) (apply-generic &#39;angle z)) (define (install-complex-package) (define (make-from-real-imag x y) ((get &#39;make-from-real-imag &#39;rectangular) x y)) (define (make-from-mag-ang r a) ((get &#39;make-from-mag-ang &#39;polar) r a)) (define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2)))) (define (sub-complex z1 z2) (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z2) (imag-part z2)))) (define (mul-complex z1 z2) (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2)))) (define (div-complex z1 z2) (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2)))) (define (equ? z1 z2) (or (and (= (real-part z1) (real-part z2)) (= (imag-part z1) (imag-part z2))) (and (= (magnitude z1) (magnitude z2)) (= (angle z1) (angle z2))))) (define (=zero? z) (or (= (magnitude z) 0) (and (= (real-part z) 0) (= (imag-part z) 0)))) (define (tag z) (attach-tag &#39;complex z)) (put &#39;real-part &#39;(complex) real-part) (put &#39;imag-part &#39;(complex) imag-part) (put &#39;magnitude &#39;(complex) magnitude) (put &#39;angle &#39;(complex) angle) (put &#39;add &#39;(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2)))) (put &#39;sub &#39;(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2)))) (put &#39;mul &#39;(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2)))) (put &#39;div &#39;(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2)))) (put &#39;equ? &#39;(complex complex) (lambda (z1 z2) (tag (equ? z1 z2)))) (put &#39;=zero? &#39;(complex) (lambda (z) (tag (=zero? z)))) (put &#39;make-from-real-imag &#39;complex (lambda (x y) (tag (make-from-real-imag x y)))) (put &#39;make-from-mag-ang &#39;complex (lambda (r a) (tag (make-from-mag-ang r a)))) &#39;done) (define (make-complex-from-real-imag x y) ((get &#39;make-from-real-imag &#39;complex) x y)) (define (make-complex-from-mag-ang r a) ((get &#39;make-from-mag-ang &#39;complex) r a)) (install-scheme-number-package) (install-rational-package) (install-rectangular-package) (install-polar-package) (install-complex-package) ;&gt;&gt;&gt; (define r1 (make-rat 1 2)) ;&gt;&gt;&gt; (define r2 (make-rat 3 4)) ;&gt;&gt;&gt; (mul r1 r2) ;: (rational 3 . 8) ;&gt;&gt;&gt; (define s1 (make-scheme-number 2)) ;&gt;&gt;&gt; (define s2 (make-scheme-number 3)) ;&gt;&gt;&gt; (div s1 s2) ;: 2/3 ;&gt;&gt;&gt; (add 3 4) ;: 7 ;&gt;&gt;&gt; (define c1 (make-complex-from-real-imag 3 4)) ;&gt;&gt;&gt; (define c2 (make-complex-from-mag-ang 5 (/ 3.1415926 4))) ;&gt;&gt;&gt; (real-part c1) ;: 3 ;&gt;&gt;&gt; (imag-part c1) ;: 4 ;&gt;&gt;&gt; (magnitude c1) ;: 5 ;&gt;&gt;&gt; (cos (angle c1)) ;: 0.6000000000000001 ;&gt;&gt;&gt; (add c1 c2) ;: (complex rectangular 6.53553395329987 . 7.535533858565605) ;&gt;&gt;&gt; (define s1 (make-scheme-number 2)) ;&gt;&gt;&gt; (define s2 (make-scheme-number 3)) ;&gt;&gt;&gt; (equ? s1 s2) ;: #f ;&gt;&gt;&gt; (equ? 4 4) ;: #t ;&gt;&gt;&gt; (define r1 (make-rat 3 4)) ;&gt;&gt;&gt; (define r2 (make-rat 3 4)) ;&gt;&gt;&gt; (equ? r1 r2) ;: #t ;&gt;&gt;&gt; (define c1 (make-complex-from-real-imag 3 4)) ;&gt;&gt;&gt; (define c2 (make-complex-from-mag-ang 5 (/ 3.1415926 4))) ;&gt;&gt;&gt; (equ? c1 c2) ;: #f ;&gt;&gt;&gt; (define s1 (make-scheme-number 2)) ;&gt;&gt;&gt; (define s2 (make-scheme-number 0)) ;&gt;&gt;&gt; (=zero? s1) ;: #f ;&gt;&gt;&gt; (=zero? s2) ;: #t ;&gt;&gt;&gt; (=zero? 0) ;: #t ;&gt;&gt;&gt; (define r1 (make-rat 0 3)) ;&gt;&gt;&gt; (define r2 (make-rat 3 4)) ;&gt;&gt;&gt; (=zero? r1) ;: #t ;&gt;&gt;&gt; (=zero? r2) ;: #f ;&gt;&gt;&gt; (define c1 (make-complex-from-real-imag 0 0)) ;&gt;&gt;&gt; (define c2 (make-complex-from-mag-ang 5 (/ 3.1415926 4))) ;&gt;&gt;&gt; (=zero? c1) ;: #t ;&gt;&gt;&gt; (=zero? c2) ;: #f 练习 81 Louis Reasoner 注意到，甚至在两个参数的类型实际相同的情况下，apply-generic 也可能试图去做参数间的类型强制。由此他推论说，需要在强制表格中加入一些过程，以将每个类型的参数“强制”到它们自己的类型。例如，除了上面给出的 scheme-number-&gt;complex 强制之外，他觉得应该有：
1 2 3 4 5 6 7 8 (define (scheme-number-&gt;scheme-number n) n) (define (complex-&gt;complex z) z) (put-coercion &#39;scheme-number &#39;scheme-number scheme-number-&gt;scheme-number) (put-coercion &#39;complex &#39;complex complex-&gt;complex) a) 如果安装了 Louis 的强制过程，如果在调用 apply-generic 时各参数的类型都为 scheme-number 或者类型都为 complex，而在表格中又找不到相应的操作，这时会出现什么情况？例如，假定我们定义了一个通用型的求幂运算：
1 (define (exp x y) (apply-generic &#39;exp x y)) 并在 Scheme 数值包里放入了一个求幂过程，但其他程序包里都没有：
1 2 3 ;;following added to Scheme-number package (put &#39;exp &#39;(scheme-number scheme-number) (lambda (x y) (tag (expt x y)))) ; using primitive expt 如果对两个复数调用 exp 会出现什么情况？
b) Louis 真的纠正了有关同样类型参数的强制问题吗？apply-generic 还能像原来那样正确工作吗？
c) 请修改 apply-generic，使之不会试着去强制两个同样类型的参数。
程序会一直做 complex 到 complex 的类型转换，陷入死循环。
没有解决，当遇到没有处理两个相同类型参数的过程时，就会陷入死循环，修改如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 (define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (if (= (length args) 2) (let ((type1 (car type-tags)) (type2 (cadr type-tags)) (a1 (car args)) (a2 (cadr args))) (if (eq? type1 type2) (error &#34;No method for these types&#34; (list op type-tags)) (let ((t1-&gt;t2 (get-coercion type1 type2)) (t2-&gt;t1 (get-coercion type2 type1))) (cond (t1-&gt;t2 (apply-generic op (t1-&gt;t2 a1) a2)) (t2-&gt;t1 (apply-generic op a1 (t2-&gt;t1 a2))) (else (error &#34;No method for these types&#34; (list op type-tags))))))) (error &#34;No method for these types&#34; (list op type-tags))))))) 练习 82 请阐述一种方法，设法推广 apply-generic，以便处理多个参数的一般性情况下的强制问题。一种可能策略是试着将所有参数都强制到第一个参数的类型，而后试着强制到第二个参数的类型，并如此试下去。请给出一个例子说明这种策略还不够一般（就像上面对两个参数的情况给出的例子那样）。（提示：请考虑一些情况，其中表格里某些合用的操作将不会被考虑。）
不够一般：可能存在相同类型的参数，此时没必要相互强制。一般化的 apply-generic 如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #lang sicp (define (same-type? type-tags) (let ((type (car type-tags))) (define (iter type-tags) (if (null? type-tags) true (and (eq? type (car type-tags)) (iter (cdr type-tags))))) (iter (cdr type-tags)))) (define (get-types type-tags) (define (iter types rest-type-tags) (if (null? rest-type-tags) types (if (memq (car rest-type-tags) types) (iter types (cdr rest-type-tags)) (iter (cons (car rest-type-tags) types) (cdr rest-type-tags))))) (iter &#39;() type-tags)) (define (coercion type args) (define (iter rest-args) (if (null? rest-args) &#39;() (let ((type2 (type-tag (car rest-args)))) (if (eq? type type2) (let ((proc (get-coercion type2 type))) (if proc (cons (proc (car rest-args)) (iter (cdr rest-args))) false)))))) (iter args)) (define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (if (same-type? type-tags) (error &#34;No method for these types&#34; (list op type-tags)) (let ((types (get-types type-tags))) (define (handle types) (if (null? types) (error &#34;No method for these types&#34; (list op type-tags)) (let ((same-type-args (coercion (car types) args))) (if same-type-args (let ((proc (get op (map type-tag same-type-args)))) (if proc (apply proc same-type-args) (handle (cdr types) args))) (handle (cdr types) args))))) (handle types))))))) 练习 83 假定你正在设计一个通用型的算术包，处理图 2-25 所示的类型塔，包括整数、有理数、实数和复数。请为每个类型（除复数外）设计一个过程，它能将该类型的对象提升到塔中的上面一层。请说明如何安装一个通用的 raise 操作，使之能对各个类型工作（除复数之外）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #lang sicp (define (raise x) (apply-generic &#39;raise x)) ;; add into scheme-number package (put &#39;raise &#39;(scheme-number) (lambda (x) (tag (make-rat x 1)))) ;; add into rational package (put &#39;raise &#39;(rational) (lambda (x) (tag (make-real (/ (numer x) (denom x)))))) ;; add into real package (put &#39;raise &#39;(real) (lambda (x) (tag (make-complex-from-real-imag x 0)))) 练习 84 利用 练习 83 的 raise 操作修改 apply-generic 过程，使它能通过逐层提升的方式将参数强制到同样的类型，正如本节中讨论的。你将需要安排一种方式，去检查两个类型中哪个更高。请以一种能与系统中其他部分“相容”，而且又不会影响向塔中加入新层次的方式完成这一工作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #lang sicp (define (same-type? type-tags) (let ((type (car type-tags))) (define (iter type-tags) (if (null? type-tags) true (and (eq? type (car type-tags)) (iter (cdr type-tags))))) (iter (cdr type-tags)))) (define (get-types type-tags) (define (iter types rest-type-tags) (if (null? rest-type-tags) types (if (memq (car rest-type-tags) types) (iter types (cdr rest-type-tags)) (iter (cons (car rest-type-tags) types) (cdr rest-type-tags))))) (iter &#39;() type-tags)) (define tower &#39;(integer rational real complex)) (define (higher? type1 type2) (let ((length1 (length (memq type1 tower))) (length2 (length (memq type2 tower)))) (&lt; length1 length2))) (define (get-top types) (define (iter top rest-types) (if (null? rest-types) top (if (higher? (car rest-types) top) (iter (car rest-types) (cdr rest-types)) (iter top (cdr rest-types))))) (iter &#39;integer types)) (define (multi-raise type arg) (if (eq? (type-tag arg) type) arg (multi-raise type (raise arg)))) (define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (if (same-type? type-tags) (error &#34;No method for these types&#34; (list op type-tags)) (let ((types (get-types type-tags))) (let ((top (get-top types))) (let ((same-type-args (map (lambda (arg) (multi-raise top arg)) args))) (let ((proc (get op (map type-tag same-type-args)))) (if proc (apply proc same-type-args) (error &#34;No method for these types&#34; (list op type-tags)))))))))))) 练习 85 本节中提到了“简化”数据对象表示的一种方法，就是使之在类型塔中尽可能地下降。请设计一个过程 drop（下落），使它能在如 练习 83 所描述的 类型塔中完成这一工作。这里的关键是以某种一般性的方式，判断一个数据对象能否下降。举例来说，复数 $1.5 + 0i$ 至多可以下降到 real，复数 $1 + 0i$ 至多可以下降到 integer，而复数 $2 + 3i$ 就根本无法下降。现在提出一种确定一个对象能否下降的计划：首先定义一个运算 project（投影），它将一个对象“压”到塔的下面一层。例如，投影一个复数就是丢掉其虚部。这样，一个数能够向下落，如果我们首先 project 它而后将得到的结果 raise 到开始的类型，最终得到的东西与开始的东西相等。请阐述实现这一想法的具体细节，并写出一个 drop 过程，使它可以将一个对象尽可能下落。你将需要设计各种各样的投影函数，并需要把 project 安装为系统里的一个通用型操作。你还需要使用一个通用型的相等谓词，例如 练习 79 所描述的。最后，请利用 drop 重写 练习 84 的 apply-generic，使之可以“简化”其结果。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #lang sicp (define (project x) (apply-generic &#39;project x)) (define (droppable? x) (equ? x (raise (project x)))) (define (drop x) (if (droppable? x) (drop (project x)) x)) ;; add into rational package (put &#39;project &#39;(rational) (lambda (x) (tag (make-scheme-number (round (/ (numer x) (denom x))))))) ;; add into real package (put &#39;project &#39;(real) (lambda (x) (tag (make-rat (* x 1e9) 1e9)))) ;; add into complex package (put &#39;project &#39;(complex) (lambda (x) (tag (make-real (real-part x))))) (define (apply-generic op . args) (let ((args2 (map drop args))) (let ((type-tags (map type-tag args2))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args2)) (if (same-type? type-tags) (error &#34;No method for these types&#34; (list op (map type-tag args))) (let ((types (get-types type-tags))) (let ((top (get-top types))) (let ((same-type-args (map (lambda (arg) (multi-raise top arg)) args2))) (let ((proc (get op (map type-tag same-type-args)))) (if proc (apply proc same-type-args) (error &#34;No method for these types&#34; (list op (map type-tag args))))))))))))) 练习 86 假定我们希望处理一些复数，它们的实部、虚部、模和幅角都可以是常规数值、有理数，或者我们希望加入系统的任何其他数值类型。请描述和实现系统需要做的各种修改，以满足这一需要。你应设法将例如 sine 和 cosine 一类的运算也定义为在常规数和有理数上的通用运算。
将复数包里面的各种基本算术操作全部替换成通用型算术操作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #lang sicp (define (sine x) (apply-generic &#39;sine x)) (define (cosine x) (apply-generic &#39;cosine x)) ;; add into scheme-number package (put &#39;sine &#39;(scheme-number) (lambda (x) (tag (sin x)))) (put &#39;cosine &#39;(scheme-number) (lambda (x) (tag (cos x)))) ;; add into rational package (pur &#39;sine &#39;(rational) (lambda (x) (tag (sin (/ (numer x) (denom x)))))) (pur &#39;cosine &#39;(rational) (lambda (x) (tag (cos (/ (numer x) (denom x)))))) 练习 87 请在通用算术包中为多项式安装 =zero?，这将使 adjoin-term 也能对系数本身也是多项式的多项式使用。
1 2 3 4 5 6 7 8 9 10 11 12 13 #lang sicp ;; add into polynomial package (define (=zero-poly? p) (define (iter terms) (if (empty-termlist? terms) true (and (=zero? (coeff (first-term terms))) (iter (rest-terms terms))))) (iter (term-list p))) (put &#39;=zero? &#39;(polynomial) (lambda (p) (=zero-poly? p))) 练习 88 请扩充多项式系统，加上多项式的减法。（提示：你可能发现定义一个通用的求负操作非常有用。）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #lang sicp (define (inverse x) (apply-generic &#39;inverse x)) ;; add into schme-number package (put &#39;inverse &#39;(scheme-number) (lambda (x) (tag (make-scheme-number (- x))))) ;; add into rational package (put &#39;inverse &#39;(rational) (lambda (x) (tag (make-rat (- (numer x)) (denom x))))) ;; add into real package (put &#39;inverse &#39;(real) (lambda (x) (tag (make-rat (- x ))))) ;; add into complex package (put &#39;inverse &#39;(complex) (lambda (x) (tag (make-complex-from-real-imag (- (real-part x)) (- (imag-part x)))))) ;; add into polynominal package (define (sub-poly p1 p2) (add-poly p2 (inverse p2))) (put &#39;inverse &#39;(polynominal) (lambda (p) (tag (make-poly (variable p) (map (lambda (term) (make-term (order term) (inverse (coeff term)))) (term-list p)))))) (put &#39;sub &#39;(polynominal polynominal) (lambda (p1 p2) (tag (sub-poly p1 p2)))) 练习 89 请定义一些过程，实现上面讨论的适宜稠密多项式的项表表示。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #lang sicp (define (adjoin-term term term-list) (if (=zero? (coeff term)) term-list (let ((order1 (order term)) (order2 (- (length term-list) 1))) (cond ((&lt; order1 order2) (cons (first-term term-list) (adjoin-term term (rest-terms term-list)))) ((= order1 order2) (cons (coeff term) (rest-terms term-list))) (else (adjoin-term term (cons 0 term-list))))))) (define (first-term term-list) (list (- (length term-list) 1) (car term-list))) 练习 90 假定我们希望有一个多项式系统，它应该对稠密多项式和稀疏多项式都非常有效。一种途径就是在我们的系统里同时允许两种表示形式。这时的情况类似于 2.4 节复数的例子，那里同时允许采用直角坐标表示和极坐标表示。为了完成这一工作，我们必须区分不同的项表类型，并将针对项表的操作通用化。请重新设计这个多项式系统，实现这种推广。这将是一项需要付出很多努力的工作，而不是一个局部修改。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #lang sicp (define (install-sparse-term-list) (define (adjoin-term term term-list) (if (=zero? (coeff term)) term-list (cons term term-list))) (define (first-term term-list) (car term-list)) (define (rest-terms term-list) (cdr term-lists)) (define (tag term-list) (attach-tag &#39;sparse term-list)) (put &#39;adjoin-term &#39;sparse adjoin-term) (put &#39;first-term &#39;(sparse) first-term) (put &#39;rest-terms &#39;(sparse) (lambda (term-list) (tag (rest-terms term-list)))) &#39;done) (define (install-dense-term-list) (define (adjoin-term term term-list) (if (=zero? (coeff term)) term-list (let ((order1 (order term)) (order2 (- (length term-list) 1))) (cond ((&lt; order1 order2) (cons (first-term term-list) (adjoin-term term (rest-terms term-list)))) ((= order1 order2) (cons (coeff term) (rest-terms term-list))) (else (adjoin-term term (cons 0 term-list))))))) (define (first-term term-list) (list (- (length term-list) 1) (car term-list))) (define (rest-terms term-list) (cdr term-lists)) (define (tag term-list) (attach-tag &#39;dense term-list)) (put &#39;adjoin-term &#39;dense adjoin-term) (put &#39;first-term &#39;(dense) first-term) (put &#39;rest-terms &#39;(dense) (lambda (term-list) (tag (rest-terms term-list)))) &#39;done) (define (adjoin-term term term-list) ((get &#39;adjoin-term (type-tag term-list)) term term-list)) (define (first-term term-list) (apply-generic &#39;first-term term-list)) (define (rest-terms term-list) (apply-generic &#39;rest-terms term-list)) 练习 91 一个单变元多项式可以除以另一个多项式，产生出一个商式和一个余式，例如
$$ \frac{x^5 - 1}{x^2 - 1} = x^3 + x\quad ,\quad\text{余式 } x - 1 $$
除法可以通过长除完成。也就是说，用被除式的最高次项除以除式的最高次项，得到商式的第一项；而后用这个结果乘以除式，并从被除式中减去这个乘积。剩下的工作就是用减后得到的差作为新的被除式，以便产生出随后的结果。当除式的次数超过被除式的次数时结束，将此时的被除式作为余式。还有，如果被除式就是 $0$，那么就返回 $0$ 作为商和余式。
我们可以基于 add-poly 和 mul-poly 的模型，设计出一个除法过程 div-poly。这一过程首先检查两个多项式是否具有相同的变元，如果是的话就剥去这一变元，将问题送给过程 div-terms，它执行项表上的除法运算。div-poly 最后将变元重新附加到 div-terms 返回的结果上。将 div-terms 设计为同时计算出除法的商式和余式是比较方便的。div-terms 可以以两个表为参数，返回一个商式的表和一个余式的表。
请完成下面 div-termns 的定义，填充其中空缺的表达式，并基于它实现 div-poly。该过程应该以两个多项式为参数，返回一个包含商和余式多项式的表。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 (define (div-terms L1 L2) (if (empty-termlist? L1) (list (the-empty-termlist) (the-empty-termlist)) (let ((t1 (first-term L1)) (t2 (first-term L2))) (if (&gt; (order t2) (order t1)) (list (the-empty-termlist) L1) (let ((new-c (div (coeff t1) (coeff t2))) (new-o (- (order t1) (order t2)))) (let ((rest-of-result &lt;递归地计算结果的其余部分&gt; )) &lt;形成完整的结果&gt; )))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #lang sicp (define (div-terms L1 L2) (if (empty-termlist? L1) (list (the-empty-termlist) (the-empty-termlist)) (let ((t1 (first-term L1)) (t2 (first-term L2))) (if (&gt; (order t2) (order t1)) (list (the-empty-termlist) L1) (let ((new-c (div (coeff t1) (coeff t2))) (new-o (- (order t1) (order t2)))) (let ((rest-of-result (div-terms (sub-terms L1 (mul-terms (list (make-term new-o new-c)) L2)) L2) )) (list (adjoin-term (make-term new-o new-c) (car rest-of-result)) (cadr rest-of-result)) )))))) (define (div-poly p1 p2) (if (same-variable? (variable p1) (variable p2)) (make-poly (variable p1) (div-terms (term-list p1) (term-list p2))) (error &#34;Polys not in same var -- DIV-POLY&#34; (list p1 p2)))) 练习 92 通过加入强制性的变量序扩充多项式程序包，使多项式的加法和乘法能对具有不同变量的多项式进行。（这绝不简单！）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #lang sicp (define types &#39;(scheme-number rational real complex)) (define (add-coercion x y) (let ((t1 (type-tag x)) (t2 (type-tag y))) (cond ((and (eq? t1 &#39;polynomial) (memq t2 types)) (add x (make-poly (variable x) (list (make-term 0 (content y)))))) ((and (memq t1 types) (eq? t2 &#39;polynominal)) (add y (make-poly (variable y) (list (make-term 0 (content x)))))) (else (add x y))))) (define (mul-coercion x y) (let ((t1 (type-tag x)) (t2 (type-tag y))) (cond ((and (eq? t1 &#39;polynomial) (memq t2 types)) (mul x (make-poly (variable x) (list (make-term 0 (content y)))))) ((and (memq t1 types) (eq? t2 &#39;polynominal)) (mul y (make-poly (variable y) (list (make-term 0 (content x)))))) (else (mul x y))))) ]]></content></entry><entry><title>Learn SICP Chapter 1</title><url>/post/sicp/learn-sicp-ch1/</url><categories><category>Learn</category></categories><tags><tag>Scheme</tag><tag>SICP</tag></tags><content type="html"><![CDATA[心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：1）将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。2）将两个认识放在一起对照，不管它们如何简单或者复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。3）将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。
John Locke, An Essay Concerning Human Understanding
( 有关人类理解的随笔，1690 ) 练习 1 下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 10 (+ 5 3 4) (- 9 1) (/ 6 2) (+ (* 2 4) (- 4 6)) (define a 3) (define b (+ a 1)) (+ a b (* a b)) (= a b) (if (and (&gt; b a) (&lt; b (* a b))) b a) (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) (+ 2 (if (&gt; b a) b a)) (* (cond ((&gt; a b) a) ((&lt; a b) b) (else -1)) (+ a 1)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #lang sicp 10 (+ 5 3 4) (- 9 1) (/ 6 2) (+ (* 2 4) (- 4 6)) (define a 3) (define b (+ a 1)) (+ a b (* a b)) (= a b) (if (and (&gt; b a) (&lt; b (* a b))) b a) (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) (+ 2 (if (&gt; b a) b a)) (* (cond ((&gt; a b) a) ((&lt; a b) b) (else -1)) (+ a 1)) ;: 10 ;: 12 ;: 8 ;: 3 ;: 6 ;: 19 ;: #f ;: 4 ;: 16 ;: 6 ;: 16 练习 2 请将下面表达式变换为前缀形式：
$$ \frac{5 + 4 + (2 - (3 - (6 + \frac{4}{5})))}{3(6 - 2)(2 - 7)} $$
1 2 3 4 5 6 #lang sicp (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7))) ;: -37/150 练习 3 请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。
1 2 3 4 5 6 7 8 9 10 11 12 13 #lang sicp (define (sum-of-max-two a b c) (if (&gt; a b) (if (&gt; b c) (+ a b) (+ a c)) (if (&gt; a c) (+ a b) (+ b c)))) ;&gt;&gt;&gt; (sum-of-max-two 233 752 666) ;: 1418 练习 4 请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面过程的行为：
1 2 (define (a-plus-abs-b a b) ((if (&gt; b 0) + -) a b)) 完成计算： $a+\lvert b\rvert$ ，如果 $b\gt 0, a+b$ ；否则， $a-b$ 。
练习 5 Ben Bitdiddle 发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是采用正则序。他定义了下面两个过程：
1 (define (p) (p)) 1 2 3 4 (define (test x y) (if (= x 0) 0 y)) 而后他求值下面的表达式：
1 (test 0 (p)) 如果某个解释器采用的是应用序求值，Ben 会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的回答做出解释。（无论采用正则序或者应用序，假定特殊形式 if 的求值规则总是一样的。其中的谓词部分先行求值，根据其结果确定随后求值的子表达式部分。）
采用的解释器为 DrRacket 的 SICP 插件环境，执行上述代码并没有任何输出，但 CPU 占用较高。因此测试环境采用的是应用序求值。
应用序求值时，会先获取每个子表达式的值，对于 (test 0 (0)) 来说，第一个参数值为 0 已知，会去求第二个参数的值，而第二个参数会一直赋值，是求不出来的，程序陷入死循环。
正则序求值时，会直接将参数代入进行计算，计算 (test 0 (p))，此时第一个参数 x 为 0，直接返回结果 0。
练习 6 Alyssa P. Hacker 看不出为什么需要将 if 提供为一种特殊形式，她问：“为什么我不能直接通过 cond 将它定义为一个常规过程呢？” Alyssa 的朋友 Eva Lu Ator 断言确实可以这样做，并定义了 if 的一个新版本：
1 2 3 (define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause))) Eva 给 Alyssa 演示她的程序：
1 2 (new-if (= 2 3) 0 5) 5 1 2 (new-if (= 1 1) 0 5) 0 她很高兴地用自己的 new-if 重写了求平方根的程序：
1 2 3 4 5 (define (sqrt-iter guess x) (new-if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) 当 Alyssa 试着用这个过程去计算平方根时会发生什么事情呢？请给出解释。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #lang sicp (define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause))) (define (sqrt-iter guess x) (new-if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) (define (improve guess x) (average guess (/ x guess))) (define (average x y) (/ (+ x y) 2)) (define (good-enough? guess x) (&lt; (abs (- (square guess) x)) 0.001)) (define (square x) (* x x)) (define (sqrt x) (sqrt-iter 1.0 x)) ;&gt;&gt;&gt; (sqrt 2) ;: Interactions disabled; out of memory 直接报错，内存超限。
由 练习 5 知，解释器采用应用序求值，因此定义的 new-if 过程会先获取所需的三个参数，而在 sqrt-iter 过程中，new-if 的 else-clause 为递归过程，因此解释器会尝试一直获取该参数的值，陷入死循环。
注：解释器提供的 if 过程为特殊过程，形式为 (if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)，会先获取 &lt;predicate&gt; 的值，如果为 #t，进入 &lt;consequent&gt;，否则进入 &lt;alternative&gt;。
练习 7 对于确定很小的数的平方根而言，在计算平方根中使用的检测 good-enough? 是很不好的。还有，在现实的计算机里，算术运算总是以一定有限精度进行的。这也会使我们的检测不适合非常大的数的计算。请解释以上论断，用例子说明对很小和很大的数，这种检测都可能失败。实现 good-enough? 的另一种策略是监测猜测值在从一次迭代到下一次的变化情况，当改变值相对于猜测值的比率很小时就结束。请设计一个采用这种终止测试方式的平方根过程。对于很大和很小的数，这一方式都能工作吗？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #lang sicp (define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) (define (improve guess x) (average guess (/ x guess))) (define (average x y) (/ (+ x y) 2)) (define (good-enough? guess x) (&lt; (abs (- (square guess) x)) 0.001)) (define (square x) (* x x)) (define (sqrt x) (sqrt-iter 1.0 x)) ;&gt;&gt;&gt; (sqrt 0.0001) ;: 0.03230844833048122 ;&gt;&gt;&gt; (sqrt 1e45) ;: 3.1622776601683792e+022 ;&gt;&gt;&gt; (sqrt 1e46) ;: 陷入死循环 对于 (sqrt 0.0001) 解释器计算结果为：0.03230844833048122 ，计算误差太大，分析可知 0.03230844833048122 的平方 0.0010438358335233748 与 0.0001 的差 0.0009438358335233748 确实小于 0.001 ，程序对此无能为力，归根结底是 good-enough? 的精度不够；解释器最大大概只能计算 (sqrt 1e45) ，对于 (sqrt 1e46) ，程序陷入死循环，但由于尾递归优化，并不会出现内存超限的情况，程序一直占用着 CPU 资源，原因也很好解释，如下：
$$ (\sqrt{x} + \Delta)^2-x=2\sqrt{x}\Delta+\Delta^2 $$
如果 $x$ 足够大， $2\sqrt{x}\Delta+\Delta^2$ 可以大于任意给定的精度，从而计算无法收敛。
基于以上的考虑，可以动态调整 $good-enough?$ 的精度。按照题目所给的实现方式，修改程序如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #lang sicp (define (sqrt-iter guess new x) (if (dynamic-good-enough? guess new) guess (sqrt-iter new (improve new x) x))) (define (improve new x) (average new (/ x new))) (define (average x y) (/ (+ x y) 2)) (define (dynamic-good-enough? old new) (&lt; (abs (- 1 (/ new old))) 0.001)) (define (square x) (* x x)) (define (sqrt x) (sqrt-iter 1.0 (improve 1.0 x) x)) ;&gt;&gt;&gt; (sqrt 0.0001) ;: 0.010000714038711746 ;&gt;&gt;&gt; (sqrt 1e45) ;: 3.1627246890405767e+022 ;&gt;&gt;&gt; (sqrt 1e46) ;: 1.000011239171839e+023 ;&gt;&gt;&gt; (sqrt 1e100) ;: 1.000000633105179e+050 练习 8 求立方根的牛顿法基于如下事实，如果 $y$ 是 $x$ 的立方根的一个近似值，那么下式将给出一个更好的近似值：
$$ \frac{x/y^2+2y}{3} $$
请利用这一公式实现一个类似平方根过程的求立方根的过程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #lang sicp (define (cube-root-iter guess new x) (if (good-enough? guess new) guess (cube-root-iter new (improve new x) x))) (define (good-enough? guess new) (&lt; (abs (- 1 (/ new guess))) 0.00001)) (define (improve new x) (average (/ x new new) new new)) (define (average x y z) (/ (+ x y z) 3)) (define (cube-root x) (cube-root-iter 1.0 (improve 1.0 x) x)) ;&gt;&gt;&gt; (cube-root 0.001) ;: 0.10000000198565878 ;&gt;&gt;&gt; (cube-root 27) ;: 3.0000005410641766 ;&gt;&gt;&gt; (cube-root 1000) ;: 10.000000145265767 ;&gt;&gt;&gt; (cube-root 1e-99) ;: 1.0000000004754588e-033 ;&gt;&gt;&gt; (cube-root 1e300) ;: 1.000001286662801e+100 练习 9 下面几个过程各定义了一种加起两个正整数的方法，它们都基于过程 inc ( 它将参数加 1 ) 和 dec ( 它将参数减 1 ) 。
1 2 3 4 (define (+ a b) (if (= a 0) b (inc (+ (dec a) b)))) 1 2 3 4 (define (+ a b) (if (= a 0) b (+ (dec a) (inc b)))) 请用代换模型展示这两个过程在求值 (+ 4 5) 时所产生的计算过程。这些计算过程是递归的或者迭代的吗？
1 2 3 4 5 6 7 8 9 10 (+ 4 5) (inc (+ 3 5)) (inc (inc (+ 2 5))) (inc (inc (inc (+ 1 5)))) (inc (inc (inc (inc (+ 0 5))))) (inc (inc (inc (inc 5)))) (inc (inc (inc 6))) (inc (inc 7)) (inc 8) 9 1 2 3 4 5 6 (+ 4 5) (+ 3 6) (+ 2 7) (+ 1 8) (+ 0 9) 9 第一个过程是递归的，第二个过程是迭代的。
练习 10 下面过程计算一个称为 Ackermann 函数的数学函数：
1 2 3 4 5 6 (define (A x y) (cond ((= y 0) 0) ((= x 0) (* 2 y)) ((= y 1) 2) (else (A (- x 1) (A x (- y 1)))))) 下面各表达式的值是什么：
1 2 3 4 5 (A 1 10) (A 2 4) (A 3 3) 请考虑下面的过程，其中的 A 就是上面定义的过程：
1 2 3 4 5 6 7 (define (f n) (A 0 n)) (define (g n) (A 1 n)) (define (h n) (A 2 n)) (define (k n) (* 5 n n)) 请给出过程 f、g 和 h 对给定整数值 $n$ 所计算的函数的数学定义。例如，(k n) 计算的是 $5n^2$。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #lang sicp (define (A x y) (cond ((= y 0) 0) ((= x 0) (* 2 y)) ((= y 1) 2) (else (A (- x 1) (A x (- y 1)))))) ;&gt;&gt;&gt; (A 1 10) ;: 1024 ;&gt;&gt;&gt; (A 2 4) ;: 65536 ;&gt;&gt;&gt; (A 3 3) ;: 65536 1 2 3 (f n) (A 0 n) 2n $$ f(n) = 2n $$
1 2 3 4 (g n) (A 1 n) (A 0 (A 1 (- n 1))) (f (g (- n 1))) $$ g(n) = f(g(n-1)) = 2g(n-1) = \ldots = 2^{n-1}g(1) = 2^n $$
1 2 3 4 (h n) (A 2 n) (A 1 (A 2 (- n 1))) (g (h (- n 1))) $$ h(n)=g(h(n-1))=2^{h(n-1)}=&hellip;=2^{2^{\cdot^{\cdot^{\cdot^{2^{h(1)}}}}}}=2^{2^{\cdot^{\cdot^{\cdot^{2^{2}}}}}} (n \text{个} 2) $$
以上过程未考虑 $n=0$ 的情况。 练习 11 函数 $f$ 由如下的规则定义：如果 $n&lt;3$，那么 $f(n)=n$；如果 $n\ge 3$，那么 $f(n)=f(n-1)+2f(n-2)+3f(n-3)$。请写一个采用递归计算过程计算 $f$ 的过程。再写一个采用迭代计算过程计算 $f$ 的过程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #lang sicp (define (f1 n) (if (&lt; n 3) n (+ (f1 (- n 1)) (* 2 (f1 (- n 2))) (* 3 (f1 (- n 3)))))) ;: 假定 n &gt;= 0 (define (f2 n) (define (f2-iter a b c n) (if (= n 2) c (f2-iter b c (+ c (* 2 b) (* 3 a)) (- n 1)))) (if (&lt; n 3) n (f2-iter 0 1 2 n))) ;&gt;&gt;&gt; (f1 30) ;: 61354575194 ;&gt;&gt;&gt; (f2 30) ;: 61354575194 练习 12 下面数值模式称为帕斯卡三角形：
1 2 3 4 5 6 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 ... 三角形边界上的数都是 1，内部的每个数是位于它上面的两个数之和。请写一个过程，它采用递归计算过程计算出帕斯卡三角形。
1 2 3 4 5 6 7 8 9 10 11 12 13 #lang sicp (define (pascal-triangle row col) (cond ((&lt; row col) -1) ((or (= col 1) (= col row)) 1) (else (+ (pascal-triangle (- row 1) (- col 1)) (pascal-triangle (- row 1) col))))) ;&gt;&gt;&gt; (pascal-triangle 4 2) ;: 3 ;&gt;&gt;&gt; (pascal-triangle 6 4) ;: 10 练习 13 证明 $\text{Fib}(n)$ 是最接近 $\phi^n/\sqrt 5$ 的整数，其中 $\phi=(1+\sqrt 5)/2$。提示：利用归纳法和斐波那契数的定义（见 1.2.2 节），证明 $\text{Fib}(n)=(\phi^n-\gamma^n)/\sqrt 5$。
$$ \begin{cases} \text{Fib}(0) = 0 \\ \text{Fib}(1) = 1 \\ \text{Fib}(n) = \text{Fib}(n-1) + \text{Fib}(n-2), n\ge 2 \end{cases} $$
当 $n\ge 2$ 时，
$$ \begin{bmatrix} \text{Fib}(n) \\ \text{Fib}(n-1) \end{bmatrix} = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} \text{Fib}(n-1) \\ \text{Fib}(n-2) \end{bmatrix} $$
记
$$ \bm{A} = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} $$
将 $\bm{A}$ 对角化如下：
$$ \bm{A} = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} = \frac{1}{\sqrt{5}} \begin{bmatrix} \phi &amp; \gamma \\ 1 &amp; 1 \end{bmatrix} \begin{bmatrix} \phi &amp; 0 \\ 0 &amp; \gamma \end{bmatrix} \begin{bmatrix} 1 &amp; -\gamma \\ -1 &amp; \phi \end{bmatrix} $$
其中，$\phi=\frac{1+\sqrt 5}{2}, \gamma=\frac{1-\sqrt 5}{2}$ 为 $\bm{A}$ 的特征值。因此：
$$ \begin{aligned} \begin{bmatrix} \text{Fib}(n) \\ \text{Fib}(n-1) \end{bmatrix} &amp;= \bm{A}^{n-1} \begin{bmatrix} \text{Fib}(1) \\ \text{Fib}(0) \end{bmatrix} \\ &amp;= \frac{1}{\sqrt 5} \begin{bmatrix} \phi &amp; \gamma \\ 1 &amp; 1 \end{bmatrix} \begin{bmatrix} \phi^{n-1} &amp; 0 \\ 0 &amp; \gamma^{n-1} \end{bmatrix} \begin{bmatrix} 1 &amp; -\gamma \\ -1 &amp; \phi \end{bmatrix} \begin{bmatrix} \text{Fib}(1) \\ \text{Fib}(0) \end{bmatrix} \\ &amp;= \frac{1}{\sqrt 5} \begin{bmatrix} \phi^n - \gamma^n &amp; \phi^{n-1} - \gamma^{n-1} \\ \phi^{n-1} - \gamma^{n-1} &amp; \phi^{n-2} - \gamma^{n-2} \end{bmatrix} \begin{bmatrix} 1 \\ 0 \end{bmatrix} \end{aligned} $$
$\Rightarrow \text{Fib}(n) = \left(\phi^n-\gamma^n\right)/{\sqrt 5} \quad (n\ge 0)$。
要证明 $\text{Fib}(n)$ 为最接近 $\phi^n/\sqrt 5$ 的整数，只需证明 $\lvert\text{Fib}(n) - \phi^n/\sqrt 5\rvert &lt; 0.5$ 即可。
$\max{\lvert\gamma^n / \sqrt 5\rvert}=\gamma^0/\sqrt 5 \approx 1/2.236 &lt; 0.5$，得证。
练习 14 请画出有关的树，展示 1.2.2 节的过程 count-change 在将 11 美分换成硬币时所产生的计算过程。相对于被换现金量的增加，这一计算过程的空间和步数增长的阶各是什么？
时间复杂度为叶节点的个数 $T(n)=\Theta(2^n)$，空间复杂度为树的深度 $S(n)=\Theta(n)$。
练习 15 在角（用弧度描述）$x$ 足够小时，其正弦值可以用 $\sin x\approx x$ 计算，而三角恒等式：
$$ \sin x =3\sin \frac{x}{3}-4\sin^3\frac{x}{3} $$
可以减小 $\sin$ 的参数的大小（为完成这一练习，我们认为一个角是“足够小”，如果其数值不大于 0.1 弧度）。这些想法都体现在下述过程中：
1 2 3 4 5 6 7 8 (define (cube x) (* x x x)) (define (p x) (- (* 3 x) (* 4 (cube x)))) (define (sine angle) (if (not (&gt; (abs angle) 0.1)) angle (p (sine (/ angle 3.0))))) a) 在求值 (sine 12.15) 时，p 将被使用多少次？
b) 在求值 (sine a) 时，由过程 sine 所产生的计算过程使用的空间和步数（作为 $a$ 的函数）增长的阶是什么？
1 2 3 4 5 6 (sine 12.15) (p (sine 4.05)) (p (p (sine 1.35))) (p (p (p (sine 0.45)))) (p (p (p (p (sine 0.15))))) (p (p (p (p (p (sine 0.05)))))) 即 p 将被使用 5 次。
时间复杂度和空间复杂度均为 $\Theta(\log a)$ 。
练习 16 请定义一个过程，它能产生出一个按照迭代方法的求幂计算过程，其中使用一系列的求平方，就像 fast-expt 一样只用对数个步骤。（提示：请利用关系 $(b^{n/2})^2=(b^2)^{n/2}$，除了指数 $n$ 和基数 $b$ 之外，还应维持一个附加的状态变量 $a$，并定义好状态变换，使得从一个状态转到另一个状态时乘积 $ab^n$ 不变。在计算过程开始时令 $a$ 取值 $1$，并用计算过程结束时 $a$ 的值作为回答，定义一个不变量，要求它在状态之间保持不变，这一技术是思考迭代算法设计问题时的一种非常强有力的方法。）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #lang sicp (define (fast-expt b n) (define (even? n) (= (remainder n 2) 0)) (define (fast-expt-iter b n a) (cond ((= n 0) a) ((even? n) (fast-expt-iter (* b b) (/ n 2) a)) (else (fast-expt-iter b (- n 1) (* a b))))) (fast-expt-iter b n 1)) ;&gt;&gt;&gt; (fast-expt 2 100) ;: 1267650600228229401496703205376 ;&gt;&gt;&gt; (fast-expt 233 666) ;: 45608249449321071866100423887710037382242303540141549438182496242630967356498403300585939221370743856986187265422069986290709044612487508462128088040902747685554711984886626823740068936201646465998047781291323652987572772058069995728882937506140140504257008579468379228550606745974431630982019632337016417060138268413281279845384946747504381921580241753023442634271482241060649036714318755753823145401892677099489710630922556129542048609567475559465982452063135308132933429890233808122027389285277264964924176508449211662347611168698873311900571051094076138040519803386754747307362834006882626700415214993070240801167355602795521863083515955510864179778671945897290584872919146476809837434854463437229210500470054228188263808948998447343504349599004630151477655748972818647675195704034143636332250506498413404529736819404059998733172045734960927853771586844272553696657099874870677594071599776653548857867859181671154866182945261398284712070353812203899610130674220038226641618463203348208551927496079463011686468216974042125906779958011178023232859028359641660595367491457705820841014430522977930845735516248984029837510541090983353875473984466834208054543087215059040900755509408687346015160580986408670546120176406650851308895847246735091833513849520187360246621896021646937864503090202916685215137385734423173203739580955346765580955409356257020956778600570894444370471939550328033688186114752380082028841287970670450765260208489908726223588727865855828074956323657564571040074575787604331082627110258301993255187030690233848909836296781038234056763169559208345629710722769 练习 17 本节里求幂算法的基础就是通过反复做乘法去求乘幂。与此类似，也可以通过反复做加法的方式求出乘积。下面的乘积过程与 expt 过程类似（其中假定我们的语言只有加法而没有乘法）：
1 2 3 4 (define (* a b) (if (= b 0) 0 (+ a (* a (- b 1))))) 这一算法具有相对于 b 的线性步数。现在假定除了加法之外还有运算 double，它能求出一个整数的两倍；还有 halve，它将一个（偶）数除以 2。请用这些运算设计一个类似 fast-expt 的求乘积过程，使之只用对数的计算步数。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #lang sicp (define (fast-mult-rec a b) (cond ((= b 0) 0) ((even? b) (fast-mult-rec (double a) (halve b))) (else (+ a (fast-mult-rec a (- b 1)))))) (define (fast-mult-iter a b) (define (fast-mult-iter-core a b p) (cond ((= b 0) p) ((even? b) (fast-mult-iter-core (double a) (halve b) p)) (else (fast-mult-iter-core a (- b 1) (+ p a))))) (fast-mult-iter-core a b 0)) (define (even? n) (= (remainder n 2) 0)) (define (double n) (+ n n)) (define (halve n) (/ n 2)) ;&gt;&gt;&gt; (fast-mult-rec 233 666) ;: 155178 ;&gt;&gt;&gt; (fast-mult-iter 233 666) ;: 155178 练习 18 利用 练习 16 和 练习 17 的结果设计一个过程，它能产生出一个基于加、加倍和折半运算的迭代计算过程，只用对数的步数就能求出两个整数的乘积。
（见 练习 17 代码 fast-mult-iter ）
练习 19 存在着一种以对数步数求出斐波那契数的巧妙算法。请回忆 1.2.2 节 fib-iter 计算过程中状态量 $a$ 和 $b$ 的变换规则，$a\leftarrow a+b$ 和 $b\leftarrow a$，现在将这种变换称为 $T$ 变换。通过观察可以发现，从 $1$ 和 $0$ 开始将 $T$ 反复应用 $n$ 次，将产生出一对数 $\text{Fib}(n+1)$ 和 $\text{Fib}(n)$。换句话说，斐波那契数可以通过将 $T^n$（变换 $T$ 的 $n$ 次方）应用于对偶 $(1, 0)$ 而产生出来。现在将 $T$ 看做是变换族 $T_{pq}$ 中 $p=0$ 且 $q=1$ 的特殊情况，其中 $T_{pq}$ 是对于对偶 $(a, b)$ 按照 $a\leftarrow bq+aq+ap$ 和 $b\leftarrow bp+aq$ 规则的变换。请证明，如果我们应用变换 $T_{pq}$ 两次，其效果等同于应用同样形式的一次变换 $T_{p&rsquo;q&rsquo;}$，其中的 $p&rsquo;$ 和 $q&rsquo;$ 可以由 $p$ 和 $q$ 计算出来。这就指明了一条求出这种变换的平方的路径，使我们可以通过连续求平方的方式去计算 $T^n$，就像 fast-expt 过程里所做的那样。将所有这些集中到一起，就形成了下面的过程，其运行只需要对数的步数：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (define (fib n) (fib-iter 1 0 0 1 n)) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b &lt;??&gt; ; compute p&#39; &lt;??&gt; ; compute q&#39; (/ count 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #lang sicp (define (fib n) (fib-iter 1 0 0 1 n)) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b (+ (* p p) (* q q)) (+ ( * 2 p q) (* q q)) (/ count 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) ;&gt;&gt;&gt; (fib 100) ;: 354224848179261915075 练习 20 一个过程所产生的计算过程当然依赖于解释器所使用的规则。作为一个例子，考虑上面给出的迭代式 gcd 过程，假定解释器用第 1.1.5 节讨论的正则序去解释这一过程（对 if 的正则序求值规则在练习 1.5 中描述）。请采用（正则序的）代换方法，展示在求值表达式 (gcd 206 40) 中产生的计算过程，并指明实际执行的 remainder 运算。在采用正则序求值 (gcd 206 40) 中实际执行了多少次 remainder 运算？如果采用应用序求值呢？
正则序：
1 2 3 4 5 6 7 8 9 10 11 12 13 (gcd 206 40) (gcd 40 (remainder 206 40)) (= (remainder 206 40) 0) (gcd (remainder 206 40) (remainder 40 (remainder 206 40))) (= (remainder 40 (remainder 206 40)) 0) (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder 6 (remainder 40 6)) (remainder 6 4) 2 实际执行了 18 次 remainder 过程。
应用序：
1 2 3 4 5 6 7 8 9 10 (gcd 206 40) (gcd 40 (remainder 206 40)) (gcd 40 6) (gcd 6 (remainder 40 6)) (gcd 6 4) (gcd 4 (remainder 6 4)) (gcd 4 2) (gcd 2 (remainder 4 2)) (gcd 2 0) 2 实际执行了 4 次 remainder 过程。
练习 21 使用 smallest-divisor 过程找出下面各数的最小因子：199、1999、19999。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #lang sicp (define (smallest-divisor n) (find-divisor n 2)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (define (square x) (* x x)) (define (divides? a b) (= (remainder b a) 0)) ;&gt;&gt;&gt; (smallest-divisor 199) ;: 199 ;&gt;&gt;&gt; (smallest-divisor 1999) ;: 1999 ;&gt;&gt;&gt; (smallest-divisor 19999) ;: 7 练习 22 大部分 Lisp 实现都包含一个 runtime 基本过程，调用它将返回一个整数，表示系统已经运行的时间（例如，以微妙计）。在对整数 $n$ 调用下面的 timed-prime-test 过程时，将打印出 $n$ 并检查 $n$ 是否为素数。如果 $n$ 是素数，过程将打印出三个星号，随后是执行这一检查所用的时间量。
1 2 3 4 5 6 7 8 9 10 11 12 (define (timed-prime-test n) (newline) (display n) (start-prime-test n (runtime))) (define (start-prime-test n start-time) (if (prime? n) (report-prime (- (runtime) start-time)))) (define (report-prime elapsed-time) (display &#34; *** &#34;) (display elapsed-time)) 请利用这一过程写一个 search-for-primes 过程，它检查给定范围内连续的各个奇数的素性。请用你的过程找出大于 1000、大于 10000、大于 100000 和大于 1000000 的三个最小的素数。请注意其中检查每个素数所需要的时间。因为这一检查算法具有 $\Theta(\sqrt n)$ 的增长阶，你可以期望在 10000 附近的素数检查的耗时大约是在 1000 附近的素数检查的 $\sqrt{10}$ 倍。你得到的数据确实如此吗？对于 100000 和 1000000 得到的数据，对这一 $\sqrt n$ 预测的支持情况如何？有人说程序在你的机器上运行的时间正比于计算所需的步数，你得到的结果符合这种说法吗？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #lang sicp (define (prime? n) (define (smallest-divisor n) (find-divisor n 2)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (define (square x) (* x x)) (define (divides? a b) (= (remainder b a) 0)) (= (smallest-divisor n) n)) (define (timed-prime-test n) (newline) (display n) (start-prime-test n (runtime))) (define (start-prime-test n start-time) (if (prime? n) (report-prime (- (runtime) start-time)))) (define (report-prime elapsed-time) (display &#34; *** &#34;) (display elapsed-time)) (define (search-for-primes start end) (cond ((&lt; start end) (timed-prime-test start) (search-for-primes (+ start 2) end)))) (search-for-primes 1001 1030) (newline) (search-for-primes 10001 10040) (newline) (search-for-primes 100001 100050) (newline) (search-for-primes 1000000001 1000000100) (newline) (search-for-primes 100000000001 100000000100) ;: 只列出了素数部分 ;: 1009 *** 0 ;: 1013 *** 0 ;: 1019 *** 0 ;: 1021 *** 0 ;: 10007 *** 0 ;: 10009 *** 0 ;: 10037 *** 0 ;: 10039 *** 0 ;: 100003 *** 0 ;: 100019 *** 0 ;: 100043 *** 0 ;: 100049 *** 0 ;: 1000000007 *** 3988 ;: 1000000009 *** 2011 ;: 1000000021 *** 1993 ;: 1000000033 *** 1995 ;: 1000000087 *** 1996 ;: 1000000093 *** 1993 ;: 1000000097 *** 1995 ;: 100000000003 *** 19947 ;: 100000000019 *** 21941 ;: 100000000057 *** 19944 ;: 100000000063 *** 19946 ;: 100000000069 *** 20945 ;: 100000000073 *** 19948 ;: 100000000091 *** 19945 从以上结果可知，在数字较小时，运行时间都为 0，无法做出判断。而在数字较大时，将数字增大 100 倍，运行时间几乎为 10 $(\sqrt{100})$ 倍，基本符合题目的说法。
练习 23 在本节开始时给出的那个 smallest-divisor 过程做了许多无用检查：在它检查了一个数是否能被 2 整除之后，实际上已经完全没必要再检查它是否能被任何偶数整除了。这说明 test-divisor 所用的值不应该是 2，3，4，5，6，&hellip;，而应该是 2，3，5，7，9，&hellip;。请实现这种修改。其中定义一个过程 next，用 2 调用时返回 3，否则就返回其输入值加 2。修改 smallest-divisor 过程，使它去使用 (next test-divisor) 而不是 (+ test-divisor 1)。让 timed-prime-test 结合这个 smallest-divisor 版本，运行练习 1.22 里的 12 个找素数测试。因为这一修改使检查的步数减少一半，你可能期望它的运行速度快一倍。实际情况符合这一预期吗？如果不符合，你所观察到的两个算法速度的比值是什么？你如何解释这一比值不是 2 的事实？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #lang sicp (define (prime? n) (define (smallest-divisor n) (find-divisor n 2)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (next test-divisor))))) (define (square x) (* x x)) (define (divides? a b) (= (remainder b a) 0)) (define (next n) (if (= n 2) 3 (+ n 2))) (= (smallest-divisor n) n)) (define (timed-prime-test n) (newline) (display n) (start-prime-test n (runtime))) (define (start-prime-test n start-time) (if (prime? n) (report-prime (- (runtime) start-time)))) (define (report-prime elapsed-time) (display &#34; *** &#34;) (display elapsed-time)) (define (search-for-primes start end) (cond ((&lt; start end) (timed-prime-test start) (search-for-primes (+ start 2) end)))) (search-for-primes 1001 1030) (newline) (search-for-primes 10001 10040) (newline) (search-for-primes 100001 100050) (newline) (search-for-primes 1000000001 1000000100) (newline) (search-for-primes 100000000001 100000000100) ;: 只列出了素数部分 ;: 1009 *** 0 ;: 1013 *** 0 ;: 1019 *** 0 ;: 1021 *** 0 ;: 10007 *** 0 ;: 10009 *** 0 ;: 10037 *** 0 ;: 10039 *** 0 ;: 100003 *** 0 ;: 100019 *** 0 ;: 100043 *** 0 ;: 100049 *** 0 ;: 1000000007 *** 996 ;: 1000000009 *** 997 ;: 1000000021 *** 997 ;: 1000000033 *** 1993 ;: 1000000087 *** 1996 ;: 1000000093 *** 998 ;: 1000000097 *** 997 ;: 100000000003 *** 12965 ;: 100000000019 *** 12969 ;: 100000000057 *** 11968 ;: 100000000063 *** 11968 ;: 100000000069 *** 12964 ;: 100000000073 *** 12966 ;: 100000000091 *** 12005 对比 练习 23 ， 练习 22 的结果，改进后的算法运行时间确实几乎为之前的一半。
练习 24 修改 练习 22 的 timed-prime-test 过程，让它使用 fast-prime?（费马方法），并检查你在练习中找出的 12 个素数。因为费马检查具有 $\Theta(\log n)$ 的增长速度，对接近 1000000 的素数检查与接近 1000 的素数检查作对期望时间之间的比较有怎样的预期？你的数据确实表明这一预期吗？你能解释所发现的任何不符合预期的地方吗？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #lang sicp (define (fast-prime? n times) (cond ((= times 0) true) ((fermat-test n) (fast-prime? n (- times 1))) (else false))) (define (fermat-test n) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1))))) (define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) (define (square x) (* x x)) (define (timed-prime-test n) (newline) (display n) (start-prime-test n (runtime))) (define (start-prime-test n start-time) (if (fast-prime? n 10) (report-prime (- (runtime) start-time)))) (define (report-prime elapsed-time) (display &#34; *** &#34;) (display elapsed-time)) (define (search-for-primes start end) (cond ((&lt; start end) (timed-prime-test start) (search-for-primes (+ start 2) end)))) (search-for-primes 1001 1030) (newline) (search-for-primes 10001 10040) (newline) (search-for-primes 100001 100050) (newline) (search-for-primes 1000000001 1000000100) ; 这一组超出了 random 范围 ; (newline) ; (search-for-primes 100000000001 100000000100) ;: 只列出了素数部分 ;: 1009 *** 0 ;: 1013 *** 0 ;: 1019 *** 0 ;: 1021 *** 0 ;: 10007 *** 0 ;: 10009 *** 0 ;: 10037 *** 0 ;: 10039 *** 0 ;: 100003 *** 0 ;: 100019 *** 0 ;: 100043 *** 0 ;: 100049 *** 0 ;: 1000000007 *** 0 ;: 1000000009 *** 0 ;: 1000000021 *** 0 ;: 1000000033 *** 0 ;: 1000000087 *** 0 ;: 1000000093 *** 0 ;: 1000000097 *** 0 运行时间都为 0，无法比较，但也确实说明了 fast-prime? 运行时间更短（对于较大的数据）。
练习 25 Alyssa P. Hacker 提出，在写 expmod 时我们做了过多的额外工作。她说，毕竟我们已经知道怎样计算乘幂，因此只需要简单地写：
1 2 (define (expmod base exp m) (remainder (fast-expt base exp) m)) 她说的对吗？这一过程能很好地用于我们的快速素数检查程序吗？请解释这些问题。
这一过程能正常工作，但是效率太低，因为在求模过程中，完全没必要把非常大的幂次算出来，而这一过程却会计算非常高的幂次，还会对其求余，导致比较大的计算开销。
练习 26 Louis Reasoner 在做 练习 24 时遇到了很大困难，它的 fast-prime? 检查看起来运行得比他的 prime? 检查还慢。Louis 请他的朋友 Eva Lu Ator 过来帮忙。在检查 Louis 的代码时，两个人发现他重写了 expmod 过程，其中用了一个显式的乘法，而没有调用 square：
1 2 3 4 5 6 7 8 9 (define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (* (expmod base (/ exp 2) m) (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) “我看不出来这会造成什么不同，” Louis 说。“我能看出，” Eva 说，“采用这种方式写出该过程时，你就把一个 $\Theta(\log n)$ 的计算过程变成 $\Theta(n)$ 的了。” 请解释这一问题。
如果采用以上过程，当 exp 为偶数时，会执行两遍 (expmod base (/ exp 2) m) 过程，达不到“折半”的效果，而 $\Theta(\log n)$ 复杂度正是由于每次使计算量“折半”得到的，上述过程将“折半”的效果“抵消”了，变成了原本的线性复杂度。
练习 27 证明脚注 47 中列出的 Carmichael 数确实能骗过费马检查。也就是说，写一个过程，它以整数 $n$ 为参数，对每个 $a\lt n$ 检查 $a^n$ 是否与 $a$ 模 $n$ 同余。用你的过程去检查前面给出的那些 Carmichael 数。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #lang sicp (define (prime? n) (define (smallest-divisor n) (find-divisor n 2)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (define (square x) (* x x)) (define (divides? a b) (= (remainder b a) 0)) (= (smallest-divisor n) n)) (define (expmod base exp m) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) (define (carmichael-test n) (if (prime? n) false (fake-fermat-test n 2))) (define (fake-fermat-test n test) (cond ((= test n) true) ((= (expmod test n n) test) (fake-fermat-test n (+ test 1))) (else false))) ; carmichael numbers: ; 561 1105 1729 2465 2821 6601 ... (carmichael-test 561) (carmichael-test 1105) (carmichael-test 1729) (carmichael-test 2465) (carmichael-test 2821) (carmichael-test 6601) (newline) (carmichael-test 2333) (carmichael-test 752) ;: #t ;: #t ;: #t ;: #t ;: #t ;: #t ;: #f ;: #f 练习 28 费马检查的一种不会被欺骗的变形成为 Miller-Rabin 检查（Miller 1976；Rabin 1980），它来源于费马小定理的一个变形。这一变形断言，如果 $n$ 是素数，$a$ 是任何小于 $n$ 的整数，则 $a$ 的 $(n-1)$ 次幂与 $1$ 模 $n$ 同余。要用 Miller-Rabin 检查考察 $n$ 的素性，我们应随机地取一个数 $a\lt n$ 并用过程 expmod 求 $a$ 的 $(n-1)$ 次幂对 $n$ 的模。然而，在执行 expmod 中的平方步骤时，我们需要查看是否遇到了“$1$ 取模 $n$ 的非平凡平方根”，也就是说，是不是存在不等于 $1$ 或者 $n-1$ 的数，其平方取模 $n$ 等于 $1$ 。可以证明，如果 $1$ 的这种非平凡平方根存在，那么 $n$ 就不是素数。还可以证明，如果 $n$ 是非素数的奇数，那么，至少有一半的数 $a\lt n$ ，按照这种方式计算 $a^{n-1}$ ，将会遇到 $1$ 取模 $n$ 的非平凡平方根。这也是 Miller-Rabin 检查不会受骗的原因。请修改 expmod 过程，让它在发现 $1$ 的非平凡平方根时报告失败，并利用它实现一个类似于 fermat-test 的过程，完成 Miller-Rabin 检查。通过检查一些已知素数和非素数的方式考验你的过程。提示：送出失败信号的一种简单方式就是让它返回 0。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #lang sicp (define (remainder-square-checked x m) (if (and (not (or (= x 1) (= x (- m 1)))) (= (remainder (* x x) m) 1)) 0 (remainder (* x x) m))) (define (expmod-checked base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder-square-checked (expmod-checked base (/ exp 2) m) m)) (else (remainder (* base (expmod-checked base (- exp 1) m)) m)))) (define (miller-rabin-test n) (define (try-it a) (= (expmod-checked a (- n 1) n) 1)) (try-it (+ 1 (random (- n 1))))) (define (miller-rabin-prime? n times) (cond ((= times 0) #t) ((miller-rabin-test n) (miller-rabin-prime? n (- times 1))) (else #f))) (define (assert-result test-name actual expected) (display (if (eq? actual expected) &#34;pass: &#34; &#34;fail: &#34;)) (display test-name) (newline)) (assert-result &#34; 2 is prime&#34; (miller-rabin-prime? 2 10) #t) (assert-result &#34;1009 is prime&#34; (miller-rabin-prime? 1009 10) #t) (assert-result &#34; 4 is not prime&#34; (miller-rabin-prime? 4 10) #f) (assert-result &#34; 99 is not prime&#34; (miller-rabin-prime? 99 10) #f) (assert-result &#34; 561 is not prime &#34; (miller-rabin-prime? 561 10) #f) ; (Carmichael number) ;: pass: 2 is prime ;: pass: 1009 is prime ;: pass: 4 is not prime ;: pass: 99 is not prime ;: pass: 561 is not prime 练习 29 辛普森规则是另一种比上面所用规则更精确的数值积分方法。采用辛普森规则，函数 $f$ 在范围 $a$ 和 $b$ 之间的定积分的近似值是：
$$ \frac{h}{3}\left[y_0+4y_1+2y_2+4y_3+2y_4+\cdots+2y_{n-2}+4y_{n-1}+y_n\right] $$
其中 $h=(b-a)/n$ , $n$ 是某个偶数，而 $y_k=f(a+kh)$ （增大 $n$ 能提高近似值的精度）。请定义一个具有参数 $f$ 、$a$ 、$b$ 和 $n$ ，采用辛普森规则计算并返回积分值的过程。用你的函数求出 cube 在 $0$ 和 $1$ 之间的积分（用 $n=100$ 和 $n=1000$ ），并将得到的值与上面用 integral 过程所得到的结果比较。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #lang sicp (define (cube x) (* x x x)) (define (sum term a next b) (if (&gt; a b) 0 (+ (term a) (sum term (next a) next b)))) (define (integral f a b dx) (define (add-dx x) (+ x dx)) (* (sum f (+ a (/ dx 2.0)) add-dx b) dx)) (define (simpson-integral f a b n) (let ((h (/ (- b a) n))) (define (next a) (+ a h h)) (* (/ h 3) (+ (f a) (* 4 (sum f (+ a h) next b)) (* 2 (sum f (+ a h h) next b)) (f b))))) (integral cube 0 1.0 0.01) (simpson-integral cube 0 1.0 100) (integral cube 0 1.0 0.001) (simpson-integral cube 0 1.0 1000) ;: 0.24998750000000042 ;: 0.25000000000000044 ;: 0.249999875000001 ;: 0.25000000000000083 采用辛普森规则的精度明显更高。
练习 30 上面的过程 sum 将产生出一个线性递归。我们可以重写该过程，使之能够迭代地执行。请说明应该怎样通过填充下面定义中缺少的表达式，完成这一工作。
1 2 3 4 5 6 (define (sum term a next b) (define (iter a result) (if &lt;??&gt; &lt;??&gt; (iter &lt;??&gt; &lt;??&gt;))) (iter &lt;??&gt; &lt;??&gt;)) 构建迭代过程，关键在于记录中间结果并完成状态转换，过程 (iter a result) 中的 result 即完成中间结果的记录，当迭代结束时，其记录值为最终结果；a 便是过程转换变量，将需要的项累加到 result 后，a 转换到下一个值，保证最终求和不变。具体代码如下：
1 2 3 4 5 6 7 8 9 10 #lang sicp (define (sum term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (+ result (term a))))) (iter a 0)) 练习 31 a）过程 sum 是可以用高阶过程表示的大量类似抽象中最简单的一个。请写出一个类似的成为 product 的过程，它返回在给定范围中各点的某个函数值的乘积。请说明如何用 product 定义 factorial 。另请按照下面公式计算 $\pi$ 的近似值：
$$ \frac{\pi}{4}=\frac{2\cdot4\cdot4\cdot6\cdot6\cdot8\cdots}{3\cdot3\cdot5\cdot5\cdot7\cdot7\cdots} $$
b）如果你的 product 过程生成的是一个递归计算过程，那么请写出一个生成迭代计算过程的过程。如果它生成一个迭代计算过程，请写出一个生成递归计算过程的过程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #lang sicp (define (product term a next b) (if (&gt; a b) 1 (* (term a) (product term (next a) next b)))) (define (factorial n) (define (next i) (+ i 1)) (define (term x) x) (product term 1 next n)) (define (calc-pi n) (define (next i) (+ i 2)) (define (term i) (/ (* (- i 1) (+ i 1)) i i)) (* 4.0 (product term 3 next n))) (define (product-iter term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (* (term a) result)))) (iter a 1)) (define (factorial-iter n) (define (next i) (+ i 1)) (define (term x) x) (product-iter term 1 next n)) (define (calc-pi-iter n) (define (next i) (+ i 2)) (define (term i) (/ (* (- i 1) (+ i 1)) i i)) (* 4.0 (product-iter term 3 next n))) (factorial 10) (calc-pi 100) (calc-pi 10000) (factorial-iter 10) (calc-pi-iter 100) (calc-pi-iter 10000) ;: 3628800 ;: 3.157339689217565 ;: 3.1417497371492673 ;: 3628800 ;: 3.157339689217565 ;: 3.1417497371492673 练习 32 a）请说明，sum 和 product（练习 1.31）都是另一称为 accumulate 的更一般概念的特殊情况，accumulate 使用某些一般性的累积函数组合起一系列项：
1 (accumulate combiner null-value term a next b) accumulate 取的是与 sum 和 product 一样的项和范围描述参数，再加上一个（两个参数的）combiner 过程，它描述如何将当前项与前面各项的积累结果组合起来，另外还有一个 null-value 参数，它描述在所有的项都用完时的基本值。请写出 accumulate ，并说明我们能怎样基于简单地调用 accumulate ，定义出 sum 和 product 来。
b）如果你的 accumulate 过程生成的是一个递归计算过程，那么请写出一个生成迭代计算过程的过程。如果它生成一个迭代计算过程，请写出一个生成递归计算过程的过程。
如下述代码所示：sum 过程的 combiner 为 + ，null-value 为 0，product 过程的 combiner 为 * ，null-value 为 1。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #lang sicp (define (accumulate combiner null-value term a next b) (if (&gt; a b) null-value (combiner (term a) (accumulate combiner null-value term (next a) next b)))) (define (accumulate-iter combiner null-value term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (combiner (term a) result)))) (iter a null-value)) (define (sum term a next b) (accumulate + 0 term a next b)) (define (product term a next b) (accumulate-iter * 1 term a next b)) (define (term x) x) (define (next n) (+ n 1)) (sum term 1 next 10) (product term 1 next 10) ;: 55 ;: 3628800 练习 33 你可以通过引进一个处理被组合项的过滤器（filter）概念，写出一个比 accumulate（练习 1.32）更一般的版本。也就是说，在计算过程中，只组合起由给定范围得到的项里的那些满足特定条件的项。这样得到的 filtered-accumulate 抽象取与上面累积过程同样的参数，再加上一个另外的描述有关过滤器的谓词参数。请写出 filtered-accumulate 作为一个过程，说明如何用 filtered-accumulate 表达以下内容：
a）求出在区间 $a$ 到 $b$ 中所有素数之和（假定你已经写出了谓词 prime? ）。
b）小于 $n$ 的所有与 $n$ 互素的正整数（即所有满足 $\text{GCD}(i, n)=1$ 的整数 $i\lt n$）之乘积。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #lang sicp (define (filtered-accumulate combiner null-value term a next b filter) (if (&gt; a b) null-value (combiner (if (filter a) (term a) null-value) (filtered-accumulate combiner null-value term (next a) next b filter)))) (define (prime? n) (define (square x) (* x x)) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (define (smallest-divisor n) (find-divisor n 2)) (= n (smallest-divisor n))) (define (coprime? n m) (define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) (= (gcd n m) 1)) (define (sum-of-primes a b) (define (term x) x) (define (next x) (+ x 1)) (filtered-accumulate + 0 term a next b prime?)) (define (product-of-coprimes n) (define (term x) x) (define (next x) (+ x 1)) (define (filter a) (coprime? n a)) (filtered-accumulate * 1 term 1 next n filter)) (sum-of-primes 2 10) (product-of-coprimes 10) ;: 17 ;: 189 练习 34 假定我们定义了：
1 2 (define f g) (g 2)) 而后就有：
1 2 3 4 5 (f square) 4 (f (lambda (z) (* z (+ z 1)))) 6 如果我们（坚持）要求解释器去求值 (f f) ，那会发生什么情况呢？请给出解释。
1 2 3 4 5 6 7 8 9 10 11 12 13 #lang sicp (define (f g) (g 2)) (f f) ;: 报错 ;: application: not a procedure; ;: expected a procedure that can be applied to arguments ;: given: 2 ;: arguments...: ;: 2 程序运行过程如下：
1 2 (f f) (f 2) 而 f 的定义中要求 f 的参数是一个过程，因此报错，期望一个过程作为参数，但提供的是数字 2 。
练习 35 请证明黄金分割率 $\phi$ （1.2.2 节）是变换 $x\mapsto 1+1/x$ 的不动点。请利用这一事实，通过过程 fixed-point 计算出 $\phi$ 的值。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #lang sicp (define tolerance 0.00001) (define (fixed-point f first-guess) (define (close-enough? v1 v2) (&lt; (abs (- v1 v2)) tolerance)) (define (try guess) (let ((next (f guess))) (if (close-enough? guess next) next (try next)))) (try first-guess)) (define golden-ratio (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0)) golden-ratio ;: 1.6180327868852458 练习 36 请修改 fixed-point ，使它能打印出计算中所产生的近似值序列，用 练习 22 展示的 newline 和 display 基本过程。而后通过找出 $x\mapsto \log(1000)/\log(x)$ 的不动点的方式，确定 $x^x=1000$ 的一个根（请利用 Scheme 的基本过程 log ，它计算自然对数值）。请比较一下采用平均阻尼和不用平均阻尼时的计算步数。（注意，你不能用猜测 1 去启动 fixed-point ，因为这将导致除以 $\log(1)=0$ 。）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #lang sicp (define tolerance 0.00001) (define (fixed-point f first-guess) (define (close-enough? v1 v2) (&lt; (abs (- v1 v2)) tolerance)) (define (try guess) (display guess) (newline) (let ((next (f guess))) (if (close-enough? guess next) next (try next)))) (try first-guess)) (fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0) (newline) (fixed-point (lambda (x) (/ (+ (/ (log 1000) (log x)) x) 2)) 2.0) ;: 2.0 ;: 9.965784284662087 ;: 3.004472209841214 ;: 6.279195757507157 ;: 3.759850702401539 ;: 5.215843784925895 ;: 4.182207192401397 ;: 4.8277650983445906 ;: 4.387593384662677 ;: 4.671250085763899 ;: 4.481403616895052 ;: 4.6053657460929 ;: 4.5230849678718865 ;: 4.577114682047341 ;: 4.541382480151454 ;: 4.564903245230833 ;: 4.549372679303342 ;: 4.559606491913287 ;: 4.552853875788271 ;: 4.557305529748263 ;: 4.554369064436181 ;: 4.556305311532999 ;: 4.555028263573554 ;: 4.555870396702851 ;: 4.555315001192079 ;: 4.5556812635433275 ;: 4.555439715736846 ;: 4.555599009998291 ;: 4.555493957531389 ;: 4.555563237292884 ;: 4.555517548417651 ;: 4.555547679306398 ;: 4.555527808516254 ;: 4.555540912917957 ;: 4.555532270803653 ;: 2.0 ;: 5.9828921423310435 ;: 4.922168721308343 ;: 4.628224318195455 ;: 4.568346513136242 ;: 4.5577305909237005 ;: 4.555909809045131 ;: 4.555599411610624 ;: 4.5555465521473675 ;: 4.555537551999825 练习 37 a）一个无穷连分式是一个如下形式的表达式：
$$ f=\frac{N_1}{D_1+\frac{N_2}{D_2+\frac{N_3}{D_3+\cdots}}} $$
作为一个例子，我们可以证明在所有的 $N_i$ 和 $D_i$ 都等于 $1$ 时，这一无穷连分式产生出 $1/\phi$ ，其中的 $\phi$ 就是黄金分割率（见 1.2.2 节的描述）。逼近某个无穷连分式的一种方法是在给定数目的项之后截断，这样的一个截断称为 $k$ 项有限连分式，其形式是：
$$ \frac{N_1}{D_1+\frac{N_2}{\ddots+\frac{N_k}{D_k}}} $$
假定 $n$ 和 $d$ 都是只有一个参数（项的下标 $i$ ）的过程，它们分别返回连分式的项 $N_i$ 和 $D_i$ 。请定义一个过程 cont-frac ，使得对 (cont-frac n d k) 的求值计算出 k 项有限连分式的值。通过如下调用检查你的过程对于顺序的 k 值是否逼近 $1/\phi$ ：
1 2 3 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) k) 你需要取多大的 k 才能保证得到的近似值具有十进制的 4 为精度？
b）如果你的计算过程产生一个递归计算过程，那么请写出另一个产生迭代计算的过程。如果它产生迭代计算，请写出另一个过程，使之产生一个递归计算过程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #lang sicp (define (cont-frac n d k) (define (rec i) (if (&gt; i k) 0 (/ (n i) (+ (d i) (rec (+ i 1)))))) (rec 1)) (define (cont-frac-iter n d k) (define (iter i res) (if (= i 0) res (iter (- i 1) (/ (n i) (+ (d i) res))))) (iter k 0)) ;: exact value: ;: 0.6180339887498948 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 10) (cont-frac-iter (lambda (i) 1.0) (lambda (i) 1.0) 11) ;: 0.6179775280898876 ;: 0.6180555555555556 练习 38 在 1737 年，瑞士数学家莱昂哈德 $\cdot$ 欧拉发表了一篇论文 De Fractionibus Continuis，文中包含了 $e-2$ 的一个连分式展开，其中的 $e$ 是自然对数的底。在这一分式中，$N_i$ 全都是 $1$ ，而 $D_i$ 依次为 $1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, \cdots$ 。请写出一个程序，其中使用你在练习 1.37 中所做的 cont-frac 过程，并能基于欧拉的展开式求出 $e$ 的近似值。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #lang sicp (define (cont-frac n d k) (define (iter i res) (if (= i 0) res (iter (- i 1) (/ (n i) (+ (d i) res))))) (iter k 0)) (+ (cont-frac (lambda (i) 1.0) (lambda (i) (if (= (remainder (+ i 1) 3) 0) (* (/ (+ i 1) 3) 2) 1)) 10) 2) (+ (cont-frac (lambda (i) 1.0) (lambda (i) (if (= (remainder (+ i 1) 3) 0) (* (/ (+ i 1) 3) 2) 1)) 1000) 2) ;: 2.7182817182817183 ;: 2.7182818284590455 练习 39 正切函数的连分式表示由德国数学家 J. H. Lambert 在 1770年发表：
$$ \tan x=\frac{x}{1-\frac{x^2}{3-\frac{x^2}{5-\ddots}}} $$
其中的 $x$ 用弧度表示。请定义过程 (tan-cf x k) ，它基于 Lambert 公式计算正切函数的近似值。k 描述的是计算的项数，就像练习 1.37 一样。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #lang sicp (define (cont-frac n d k) (define (iter i res) (if (= i 0) res (iter (- i 1) (/ (n i) (+ (d i) res))))) (iter k 0)) (define (tan-cf x k) (cont-frac (lambda (i) (if (= i 1) x (- (* x x)))) (lambda (i) (- (+ i i) 1)) k)) (tan-cf 0.0 10) (tan-cf (/ 3.1415926 4) 100) ;: 0.0 ;: 0.9999999732051038 练习 40 请定义一个过程 cubic ，它和 newtons-method 过程一起使用在下面形式的表达式里：
1 (newtons-method (cubic a b c) 1) 能逼近三次方程 $x^3+ax^2+bx+c$ 的零点。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #lang sicp (define tolerance 0.00001) (define (fixed-point f first-guess) (define (close-enough? v1 v2) (&lt; (abs (- v1 v2)) tolerance)) (define (try guess) (let ((next (f guess))) (if (close-enough? guess next) next (try next)))) (try first-guess)) (define dx 0.00001) (define (deriv g) (lambda (x) (/ (- (g (+ x dx)) (g x)) dx))) (define (newton-transform g) (lambda (x) (- x (/ (g x) ((deriv g) x))))) (define (newtons-method g guess) (fixed-point (newton-transform g) guess)) (define (cubic a b c) (lambda (x) (+ (* x x x) (* a x x) (* b x) c))) (newtons-method (cubic -2.0 -2.0 3.0) 1) (newtons-method (cubic 2 3 3) 1) ;: 1.0 ;: -1.3926467817024144 练习 41 请定义一个过程 double ，它以一个有一个参数的过程作为参数，double 返回一个过程。这一过程将原来那个参数过程应用两次。例如，若 inc 是个给参数加 1 的过程，(double inc) 将给参数加 2 。下面表达式返回什么值：
1 (((double (double double)) inc) 5) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #lang sicp (define (double f) (lambda (x) (f (f x)))) (((double (double double)) inc) 5) (((lambda (x) ((double double) ((double double) x))) inc) 5) (((lambda (x) ((lambda (x) (double (double x))) ((lambda (x) (double (double x))) x))) inc) 5) (((lambda (x) ((lambda (x) (double (double x))) (double (double x)))) inc) 5) (((lambda (x) (double (double (double (double x))))) inc) 5) ((double (double (double (double inc)))) 5) (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc 5)))))))))))))))) ;: 21 ;: 21 ;: 21 ;: 21 ;: 21 ;: 21 ;: 21 练习 42 令 $f$ 和 $g$ 是两个单参数的函数，$f$ 和 $g$ 之后的复合定义为函数 $x\mapsto f\left(g(x)\right)$ 。请定义一个函数 compose 实现函数复合。例如，如果 inc 是将参数加 1 的函数，那么：
1 2 ((compose square inc) 6) 49 1 2 3 4 5 6 7 8 #lang sicp (define (compose f g) (lambda (x) (f (g x)))) ((compose (lambda (x) (* x x)) inc) 6) ;: 49 练习 43 如果 $f$ 是一个数值函数，$n$ 是一个正整数，那么我们可以构造出 $f$ 的 $n$ 次重复应用，将其定义为一个函数，这个函数在 $x$ 的值是 $f(f(\cdots(f(x))\cdots))$ 。举例说，如果 $f$ 是函数 $x\mapsto x+1$ ，$n$ 次重复应用 $f$ 就是函数 $x\mapsto x+n$ 。如果 $f$ 是求一个数的平方的操作，$n$ 次重复应用 $f$ 就求出其参数的 $2^n$ 次幂。请写出一个过程，它的输入是一个计算 $f$ 的过程和一个正整数 $n$ ，返回的是能计算 $f$ 的 $n$ 次重复应用的那个函数。你的过程应该能以如下方式使用：
1 2 ((repeated square 2) 5) 625 提示：你可能发现使用 练习 42 的 compose 能带来一些方便。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #lang sicp (define (compose f g) (lambda (x) (f (g x)))) (define (repeated f n) (if (= n 1) f (compose (repeated f (- n 1)) f))) ((repeated (lambda (x) (* x x)) 2) 5) ((repeated (lambda (x) (+ x 1)) 100) 100) ;: 625 ;: 200 练习 44 平滑一个函数的想法是信号处理中的一个重要概念。如果 $f$ 是一个函数，$dx$ 是某个很小的数值，那么 $f$ 的平滑也是一个函数，它在点 $x$ 的值就是 $f(x-dx)$ 、$f(x)$ 和 $f(x+dx)$ 的平均值。请写出一个过程 smooth ，它的输入是一个计算 $f$ 的过程，返回一个计算平滑后的 $f$ 的过程。有时可能发现，重复地平滑一个函数，得到经过 $n$ 次平滑的函数（也就是说，对平滑后的函数再做平滑，等等）也很有价值。说明怎样利用 smooth 和练习 1.43 的 repeated ，对给定的函数生成 $n$ 次平滑函数。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #lang sicp (define (repeated f n) (if (= n 1) f (lambda (x) ((lambda (f g) (f (g x))) (repeated f (- n 1)) f)))) (define dx 0.00001) (define (smooth f) (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3))) (define (multi-smooth f n) (repeated (smooth f) n)) ((smooth (lambda (x) (* x x))) 1) ((smooth (lambda (x) (* x x x))) 0) ((multi-smooth (lambda (x) (* x x)) 1) 1) ((multi-smooth (lambda (x) (* x x)) 10) 1) ;: 1.0000000000666667 ;: 0.0 ;: 1.0000000000666667 ;: 1.0000000682000072 练习 45 在 1.3.3 节里，我们看到企图用朴素的方法去找 $y\mapsto x/y$ 的不动点，以便计算平方根的方式不收敛，这个缺陷可以通过平均阻尼的方式弥补。同样方法也用于找立方根，将它看做是平均阻尼后的 $y\mapsto x/y^2$ 的不动点。遗憾的是，这一计算过程对于四次方根却行不通，一次平均阻尼不足以使对 $y\mapsto x/y^3$ 的不动点搜寻收敛。而在另一方面，如果我们求两次平均阻尼（即，用 $y\mapsto x/y^3$ 的平均阻尼的平均阻尼），这一不动点搜寻就会收敛了。请做一些试验，考虑将计算 $n$ 次方根作为基于 $y\mapsto x/y^{n-1}$ 的反复做平均阻尼的不动点搜寻过程，请设法确定各种情况下需要做多少次平均阻尼。并请基于这一认识实现一个过程，它使用 fixed-point 、average-damp 和 练习 43 的 repeated 过程计算 $n$ 次方根。假定你所需要的所有算术运算都是基本过程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #lang sicp (define (average-damp f) (lambda (x) (/ (+ x (f x)) 2))) (define tolerance 0.00001) (define (fixed-point f first-guess) (define (close-enough? a b) (&lt; (abs (- a b)) tolerance)) (define (try guess) (let ((next (f guess))) (if (close-enough? guess next) next (try next)))) (try first-guess)) (define (repeated f n) (if (= n 1) f (lambda (x) (f ((repeated f (- n 1)) x))))) (define (damp-times n) (define (iter power k) (if (&lt; n power) (- k 1) (iter (+ power power) (+ k 1)))) (iter 1 0)) (define (n-th-root x n) (fixed-point ((repeated average-damp (damp-times n)) (lambda (y) (/ x ((repeated (lambda (xx) (* y xx)) (- n 1)) 1.0)))) 1.0)) (n-th-root 32 5) (n-th-root 2 20) ;: 2.0000015129957607 ;: 1.0352662146623808 练习 46 本章描述的一些数值算法都是迭代式改进的实例。迭代式改进是一种非常具有一般性的计算策略，它说的是：为了计算出某些东西，我们可以从对答案的某个初始猜测开始，检查这一猜测是否足够好，如果不行就改进这一猜测，将改进之后的猜测作为新的猜测继续这一计算过程。请写一个过程 iterative-improve ，它以两个过程为参数：其中之一表示告知某一猜测是否足够好的方法，另一个表示改进猜测的方法。iterative-improve 的返回值应该是一个过程，它以某一个猜测为参数，通过不断改进，直至得到的猜测足够好为止。利用 iterative-improve 重写 1.1.7 节的 sqrt 过程和 1.3.3 节的 fixed-point 过程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #lang sicp (define (iterative-improve good-enough? improve) (define (iter guess) (if (good-enough? guess) guess (iter (improve guess)))) (lambda (guess) (iter guess))) (define (sqrt x) ((iterative-improve (lambda (y) (&lt; (abs (- x (* y y))) 0.00001)) (lambda (y) (/ (+ y (/ x y)) 2))) x)) (define (fixed-point f first-guess) ((iterative-improve (lambda (y) (&lt; (abs (- y (f y))) 0.00001)) (lambda (y) (f y))) first-guess)) (sqrt 2.0) (fixed-point cos 1.0) ;: 1.4142156862745097 ;: 0.7390893414033927 ]]></content></entry></search>